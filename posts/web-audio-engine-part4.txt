3:I[6939,["629","static/chunks/f93eae9e-e54bf136a3920da1.js","259","static/chunks/259-bd25116a2e099f04.js","727","static/chunks/727-5b9b753daf1ddd23.js","840","static/chunks/app/posts/web-audio-engine-part4/page-b5c9e3e1c452a95f.js"],""]
4:I[2566,[],""]
5:I[9663,[],""]
6:I[1167,["259","static/chunks/259-bd25116a2e099f04.js","727","static/chunks/727-5b9b753daf1ddd23.js","513","static/chunks/513-0f61edff8b267366.js","517","static/chunks/app/posts/layout-fabdd2c2c154abfd.js"],""]
7:I[4727,["629","static/chunks/f93eae9e-e54bf136a3920da1.js","221","static/chunks/53dc2434-ff571755d6d243ce.js","259","static/chunks/259-bd25116a2e099f04.js","727","static/chunks/727-5b9b753daf1ddd23.js","931","static/chunks/app/page-f25cc2ef10785dc0.js"],""]
2:T4b2,// file: /src/core/Routes.ts
export class Routes {
  engine: Engine;
  routes: { [key: string]: IRoute };

  constructor(engine: Engine) {
    this.engine = engine;
    this.routes = {};
  }

  addRoute(props: Optional<IRoute, "id">) {
    const id = props.id || uuidv4();
    this.routes[id] = { ...props, id };

    this.plug(id);
  }

  removeRoute(id: string) {
    this.unPlug(id);
    delete this.routes[id];
  }

  private plug(id: string) {
    const { sourceIO, destinationIO } = this.getIOs(id);
    sourceIO.plug(destinationIO);
  }

  private unPlug(id: string) {
    const { sourceIO, destinationIO } = this.getIOs(id);
    sourceIO.unPlug(destinationIO);
  }

  private find(id: string): IRoute {
    if (!this.routes[id]) throw Error(`Route with id ${id} not found`);

    return this.routes[id];
  }

  private getIOs(id: string) {
    const route = this.find(id);
    const { source, destination } = route;

    const sourceIO = this.engine.findIO(
      source.moduleId,
      source.ioName,
      "output",
    );
    const destinationIO = this.engine.findIO(
      destination.moduleId,
      destination.ioName,
      "input",
    );

    return { sourceIO, destinationIO };
  }
}
0:["W5J-sALC7wEV2RYOSxjL9",[[["",{"children":["posts",{"children":["web-audio-engine-part4",{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",{"children":["posts",{"children":["web-audio-engine-part4",{"children":["__PAGE__",{},["$L1",[["$","h1",null,{"children":"Web Audio Engine Part 4 - implementing Advanced I/O"}],"\n",["$","p",null,{"children":["In the ",["$","a",null,{"href":"/posts/web-audio-engine-part3","children":"previous post"}],", we began integrating Web Audio and implemented a basic connect functionality, allowing us to link modules together.\nHowever, this basic functionality has limitations when it comes to building more complex audio systems. It lacks the flexibility and control needed for advanced audio processing tasks."]}],"\n",["$","p",null,{"children":"To overcome these limitations, in this post, we will explore and implement a more advanced and modular I/O system.\nThis new system will provide greater control over connections, enabling us to create more intricate and scalable audio setups.\nAdditionally, this enhanced I/O system will offer users detailed information about the available I/Os of a module and the current connections between these I/Os."}],"\n",["$","p",null,{"children":["Before we continue I'm suggesting to do a fast diagonal reading if you have already read it before, or a more detailed reading if you haven't to\n",["$","a",null,{"href":"/posts/web-audio-engine-part1","children":"part1"}],",\n",["$","a",null,{"href":"/posts/web-audio-engine-part2","children":"part2"}],",\n",["$","a",null,{"href":"/posts/web-audio-engine-part3","children":"part3"}],"."]}],"\n",["$","p",null,{"children":["You can find the codebase up to this point on the ",["$","a",null,{"href":"https://github.com/mikezaby/web_audio_engine/tree/advanced-io","children":"advanced-io"}]," branch,\nor you can view the additions compared with the previous post ",["$","a",null,{"href":"https://github.com/mikezaby/web_audio_engine/compare/audio-node...advanced-io","children":"here"}],"."]}],"\n",["$","h2",null,{"children":"Data Structure"}],"\n",["$","p",null,{"children":"We will start with the data structure."}],"\n",["$","p",null,{"children":"First, let's describe the data structure of an I/O:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"{\n  id: string,\n  name: string,\n  ioType: IOType,\n  moduleId: string,\n}\n"}]}],"\n",["$","p",null,{"children":["The ",["$","code",null,{"children":"IOType"}]," will keep all the available I/O types that we will implement.\nIn this post, we will implement ",["$","code",null,{"children":"AudioInput"}]," and ",["$","code",null,{"children":"AudioOutput"}],", but in the next iteration, we will add support for ",["$","code",null,{"children":"MidiInput"}]," and ",["$","code",null,{"children":"MidiOutput"}],"."]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/Base.ts\nenum IOType {\n  AudioInput = \"audioInput\",\n  AudioOutput = \"audioOutput\",\n}\n"}]}],"\n",["$","p",null,{"children":["Next, we want to define the data structure that describes the connection between an input and an output.\nWe name this connection a ",["$","code",null,{"children":"Route"}],"."]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"{\n  id: string,\n  source: { ioName: string, moduleId: string },\n  destination: { ioName: string, moduleId: string }\n}\n"}]}],"\n",["$","p",null,{"children":["We decided to use ",["$","code",null,{"children":"ioName"}]," and ",["$","code",null,{"children":"moduleId"}]," as the information for the source and destination instead of just the I/O id.\nThis decision allows us to quickly determine which module an I/O belongs to, and using ioName instead of an id makes it more human-friendly.\nWe also enforce unique name validation to avoid problems with duplicate names."]}],"\n",["$","p",null,{"children":"So this information is enough to know which I/Os are available and the connections between them."}],"\n",["$","h2",null,{"children":"File Structure"}],"\n",["$","p",null,{"children":["In this post, we will implement the ",["$","code",null,{"children":"Base"}]," class for our I/O, the ",["$","code",null,{"children":"AudioIO"}],", which will handle the connections between ",["$","code",null,{"children":"AudioNode"}]," outputs and ",["$","code",null,{"children":"AudioNode"}]," inputs or ",["$","code",null,{"children":"AudioParams"}],".\nAdditionally, we will implement a collection that will help us define easily the desired inputs and outputs for each module."]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"- src\n  - core\n    - IO\n      - index.ts\n      - Base.ts\n      - AudioIO.ts\n      - Collection.ts\n"}]}],"\n",["$","h2",null,{"children":"The Base IO Class"}],"\n",["$","p",null,{"children":"We want to define the interface for the I/O based on the data that we showed before.\nTo initialize an I/O, we need to know the name of the I/O and its type."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/Base.ts\ninterface IOProps {\n  name: string;\n  ioType: IOType;\n}\n"}]}],"\n",["$","p",null,{"children":"For serialization, we need to extend the previous interface with the information of I/O id and moduleId."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/Base.ts\ninterface IIOSerialize extends IOProps {\n  id: string;\n  moduleId: string;\n}\n"}]}],"\n",["$","h3",null,{"children":"Constructor"}],"\n",["$","p",null,{"children":"To define an I/O, we also need to know which module it belongs to, for this reason, we pass this argument in the constructor.\nWe use a deterministic id generation based on module id and I/O name.\nWe do this because we want unique ids, but we also want the ability to reproduce the same id when we have the same module id and I/O name.\nLastly, we want to keep track of the connections of this I/O."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/Base.ts\nabstract class Base implements IOProps {\n  id: string;\n  ioType: IOType;\n  name: string;\n  module: AnyModule;\n  connections: Base[];\n\n  constructor(module: AnyModule, props: IOProps) {\n    this.module = module;\n    this.name = props.name;\n    this.ioType = props.ioType;\n    this.id = deterministicId(this.module.id, this.name);\n    this.connections = [];\n  }\n}\n"}]}],"\n",["$","h3",null,{"children":"Plug/UnPlug"}],"\n",["$","p",null,{"children":"We want a standardized procedure for any I/O type that can be plugged or unplugged, and these functions can be overridden with extra logic based on specific I/O type needs.\nThe only thing that we want from basic plug/unplug functionality is to update the connections.\nAlso, because we want both input and output informed about the connection, we have a flag to know if we need to call the plug/unPlug function in the opposite way.\nWe also have an unPlugAll functionality to easily unplug all connections."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/Base.ts\nplug(io: Base, plugOther: boolean = true) {\n  this.connections.push(io);\n  if (plugOther) io.plug(this, false);\n}\n\nunPlug(io: Base, plugOther: boolean = true) {\n  this.connections = this.connections.filter(\n    (currentIO) => currentIO.id !== io.id,\n  );\n  if (plugOther) io.unPlug(this, false);\n}\n\nunPlugAll() {\n  this.connections.forEach((otherIO) => this.unPlug(otherIO));\n}\n"}]}],"\n",["$","h3",null,{"children":"Serialize"}],"\n",["$","p",null,{"children":["We want to serialize the data of the I/O based on what we discussed in the ",["$","strong",null,{"children":"Data Structure"}]," section."]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/Base.ts\nserialize(): IIOSerialize {\n  return {\n    id: this.id,\n    name: this.name,\n    ioType: this.ioType,\n    moduleId: this.module.id,\n  };\n}\n"}]}],"\n",["$","h3",null,{"children":"Handling Connection As Geneneric"}],"\n",["$","p",null,{"children":["In some cases may we don't want to change to plug/unPlug anything else than what is the ",["$","code",null,{"children":"Connection"}],",\nso we make an aditional class that will extends ",["$","code",null,{"children":"Base"}]," with the ability to set a generic about the ",["$","code",null,{"children":"Connection"}],"."]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/Base.ts\nabstract class IO<Connection extends Base> extends Base {\n  declare connections: Connection[];\n\n  constructor(module: AnyModule, props: IOProps) {\n    super(module, props);\n  }\n\n  plug(io: Connection, plugOther?: boolean): void {\n    super.plug(io, plugOther);\n  }\n\n  unPlug(io: Connection, plugOther?: boolean): void {\n    super.unPlug(io, plugOther);\n  }\n}\n"}]}],"\n",["$","h2",null,{"children":"AudioIO"}],"\n",["$","p",null,{"children":["We want to adjust ",["$","code",null,{"children":"IOProps"}]," to set specific types for ",["$","code",null,{"children":"AudioInputProps"}]," and ",["$","code",null,{"children":"AudioOutputProps"}],", and extend them with an extra field ",["$","code",null,{"children":"getAudioNode"}],", which is a callback that returns an ",["$","code",null,{"children":"AudioNode"}]," for output, as only the AudioNode has the ability to call connect.\nFor inputs, the callback returns an ",["$","code",null,{"children":"AudioNode"}],", ",["$","code",null,{"children":"AudioParam"}],", or ",["$","code",null,{"children":"AudioDestinationNode"}]," because all of this are able to be connected to an AudioNode.\nWe use a callback instead of a simple property because the AudioNode may change.\nFor example, with an Oscillator, we have to create a new OscillatorNode every time we stop it."]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/AudioIO.ts\nexport interface AudioInputProps extends IOProps {\n  ioType: IOType.AudioInput;\n  getAudioNode: () => AudioNode | AudioParam | AudioDestinationNode;\n}\n\nexport interface AudioOutputProps extends IOProps {\n  ioType: IOType.AudioOutput;\n  getAudioNode: () => AudioNode;\n}\n"}]}],"\n",["$","p",null,{"children":["The implementation of ",["$","code",null,{"children":"AudioInput"}]," is straightforward:"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/AudioIO.ts\nclass AudioInput extends IO<AudioOutput> implements AudioInputProps {\n  declare ioType: IOType.AudioInput;\n  getAudioNode: AudioInputProps[\"getAudioNode\"];\n\n  constructor(module: AnyModule, props: AudioInputProps) {\n    super(module, props);\n    this.getAudioNode = props.getAudioNode;\n  }\n}\n"}]}],"\n",["$","p",null,{"children":["In the ",["$","code",null,{"children":"AudioOutput"}],", we will add the extra code that should be executed when we plug or unplug."]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/AudioIO.ts\nexport class AudioOutput extends IO<AudioInput> implements AudioOutputProps {\n  declare ioType: IOType.AudioOutput;\n  getAudioNode!: AudioOutputProps[\"getAudioNode\"];\n\n  constructor(module: AnyModule, props: AudioOutputProps) {\n    super(module, props);\n    this.getAudioNode = props.getAudioNode;\n  }\n\n  plug(io: AudioInput, plugOther: boolean = true) {\n    super.plug(io, plugOther);\n    const input = io.getAudioNode();\n\n    if (input instanceof AudioParam) {\n      this.getAudioNode().connect(input);\n    } else {\n      this.getAudioNode().connect(input);\n    }\n  }\n\n  unPlug(io: AudioInput, plugOther: boolean = true) {\n    super.unPlug(io, plugOther);\n    const input = io.getAudioNode();\n\n    try {\n      if (input instanceof AudioParam) {\n        this.getAudioNode().disconnect(input);\n      } else {\n        this.getAudioNode().disconnect(input);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n"}]}],"\n",["$","p",null,{"children":["Unfortunately, we have an awkward handling to connect an ",["$","code",null,{"children":"AudioNode"}]," to an ",["$","code",null,{"children":"AudioParam"}],".\nWhile the connect method allows connecting an ",["$","code",null,{"children":"AudioNode"}]," to an ",["$","code",null,{"children":"AudioParam"}],", due to a TypeScript ",["$","a",null,{"href":"https://github.com/microsoft/TypeScript/issues/14107","children":"issue"}],", we have to handle it like this."]}],"\n",["$","h2",null,{"children":"Collection"}],"\n",["$","p",null,{"children":["The last tool for I/O will be the ",["$","code",null,{"children":"Collection"}],".\nWe want the integration to be as easy as possible and ensure proper separation of concerns.\nTherefore, we need a class that will serve as a collection of Inputs or Outputs and handle tasks such as adding a new I/O, finding an existing one, and serializing the collection."]}],"\n",["$","p",null,{"children":"As mentioned, we want two collection types: Input and Output.\nCurrently, we have only one type of Node for each collection type."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/Collection.ts\nenum CollectionType {\n  Input = \"Input\",\n  Output = \"Output\",\n}\n"}]}],"\n",["$","h3",null,{"children":"Constructor"}],"\n",["$","p",null,{"children":["We need a class that will take a generic type representing the ",["$","code",null,{"children":"CollectionType"}],".\nWe will use this generic type later to match properties appropriately based on the collection type."]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/Collection.ts\nabstract class IOCollection<T extends CollectionType> {\n  module: AnyModule;\n  collection: Base[] = [];\n  collectionType: T;\n\n  constructor(collectionType: T, module: AnyModule) {\n    this.collectionType = collectionType;\n    this.module = module;\n  }\n}\n"}]}],"\n",["$","h3",null,{"children":"Add I/O"}],"\n",["$","p",null,{"children":"We want to create an interface that will map the appropriate properties based on the collection type.\nThis allows us to avoid incorrect usage at an early stage through type checking.\nFinally, we need to validate the uniqueness of the I/O name in this collection."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/Collection.ts\ninterface IMappedIOProps {\n  [CollectionType.Input]: AudioInputProps;\n  [CollectionType.Output]: AudioOutputProps;\n}\n"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/Collection.ts\nadd(props: IMappedIOProps[T]) {\n  let io: Base;\n  this.validateUniqName(props.name);\n\n  switch (props.ioType) {\n    case IOType.AudioInput:\n      io = new AudioInput(this.module, props);\n      break;\n    case IOType.AudioOutput:\n      io = new AudioOutput(this.module, props);\n      break;\n    default:\n      assertNever(props);\n  }\n\n  this.collection.push(io);\n\n  return io;\n}\n"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/Collection.ts\nprivate validateUniqName(name: string) {\n  if (this.collection.some((io) => io.name === name)) {\n    throw Error(`An I/O with name ${name} already exists`);\n  }\n}\n"}]}],"\n",["$","h3",null,{"children":"Finders And Serializer"}],"\n",["$","p",null,{"children":"These functions are straightforward:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/Collection.ts\nfind(id: string) {\n  const io = this.collection.find((io) => io.id === id);\n  if (!io) throw Error(`The I/O with id ${id} does not exists`);\n\n  return io;\n}\n\nfindByName(name: string) {\n  const io = this.collection.find((io) => io.name === name);\n  if (!io) throw Error(`The I/O with name ${name} does not exists`);\n\n  return io;\n}\n\nserialize() {\n  return this.collection.map((io) => io.serialize());\n}\n"}]}],"\n",["$","h3",null,{"children":"Input/OutputCollection"}],"\n",["$","p",null,{"children":["To facilitate easier usage in the module, we expose ",["$","code",null,{"children":"InputCollection"}]," and ",["$","code",null,{"children":"OutputCollection"}],":"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/Collection.ts\nexport class InputCollection extends IOCollection<CollectionType.Input> {\n  constructor(module: AnyModule) {\n    super(CollectionType.Input, module);\n  }\n}\n\nexport class OutputCollection extends IOCollection<CollectionType.Output> {\n  constructor(module: AnyModule) {\n    super(CollectionType.Output, module);\n  }\n}\n"}]}],"\n",["$","h2",null,{"children":"Base Module Integration"}],"\n",["$","p",null,{"children":"In the Base module constructor, we initialize Input/OutputCollection:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/Module.ts\n// function: constructor\nthis.inputs = new InputCollection(this);\nthis.outputs = new OutputCollection(this);\n"}]}],"\n",["$","p",null,{"children":"Then we want to provide an easy way to define audio inputs/outputs:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/Module.ts\nprotected registerAudioInput(props: Omit<AudioInputProps, \"ioType\">) {\n  this.inputs.add({ ...props, ioType: IOType.AudioInput });\n}\n\nprotected registerAudioOutput(props: Omit<AudioOutputProps, \"ioType\">) {\n  this.outputs.add({ ...props, ioType: IOType.AudioOutput });\n}\n"}]}],"\n",["$","p",null,{"children":["We will see the usage of this as we also want to give the ability to define some common I/Os.\nThe most common case is to define the module's main input and output ",["$","code",null,{"children":"AudioNode"}],"."]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/Module.ts\nprotected registerDefaultIOs(value: \"both\" | \"in\" | \"out\" = \"both\") {\n  if (value === \"in\" || value === \"both\") {\n    this.registerAudioInput({\n      name: \"in\",\n      getAudioNode: () => this.audioNode,\n    });\n  }\n\n  if (value === \"out\" || value === \"both\") {\n    this.registerAudioOutput({\n      name: \"out\",\n      getAudioNode: () => this.audioNode,\n    });\n  }\n}\n"}]}],"\n",["$","p",null,{"children":"We also want to add information about the available I/Os to the serialize function:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/Module.ts\ninterface IModuleSerialize<T extends ModuleType> extends IModule<T> {\n  inputs: IIOSerialize[];\n  outputs: IIOSerialize[];\n}\n"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/Module.ts\nserialize(): IModuleSerialize<T> {\n  return {\n    id: this.id,\n    name: this.name,\n    moduleType: this.moduleType,\n    props: this.props,\n    inputs: this.inputs.serialize(),\n    outputs: this.outputs.serialize(),\n  };\n}\n"}]}],"\n",["$","h2",null,{"children":"Define I/Os To Available Modules"}],"\n",["$","p",null,{"children":"Now we are ready to define the I/Os for the actual modules."}],"\n",["$","h3",null,{"children":"Volume"}],"\n",["$","p",null,{"children":"The volume module has both an input and an output, as we connect a signal to its input and take the adjusted signal from its output.\nSo, we will define both input and output."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/modules/Volume.ts\n// function: constructor\nthis.registerDefaultIOs();\n"}]}],"\n",["$","h3",null,{"children":"Master"}],"\n",["$","p",null,{"children":"The master module has only an input, which allows any module to reach our audio interface."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/modules/Master.ts\n// function: constructor\nthis.registerDefaultIOs(\"in\");\n"}]}],"\n",["$","h3",null,{"children":"Oscillator"}],"\n",["$","p",null,{"children":"Conversely, the oscillator has only an output, as the oscillator generates the signal."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/modules/Oscillator.ts\n// function: constructor\n\nthis.initializeGainDetune();\nthis.registerDefaultIOs(\"out\");\nthis.registerInputs();\n"}]}],"\n",["$","p",null,{"children":["However, we will define an input for the ",["$","code",null,{"children":"detune"}]," ",["$","code",null,{"children":"AudioParam"}],".\nWith this setup, we allow the ability to automatically mutate the frequency.\nFor example, we can connect another oscillator to detune."]}],"\n",["$","p",null,{"children":["The ",["$","code",null,{"children":"OscillatorNode.detune"}]," parameter changes the original frequency by one semitone for every 100 cents.\nWe want to apply values from -1 to 1 to change the original frequency by one semitone.\nTherefore, we create an extra ",["$","code",null,{"children":"GainNode"}]," with a value of 100, connect it to ",["$","code",null,{"children":"audioNode.detune"}],", and then expose the ",["$","code",null,{"children":"detuneGain"}]," instead of ",["$","code",null,{"children":"audioNode.detune"}],"."]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/modules/Oscillator.ts\nprivate initializeGainDetune() {\n  this.detuneGain = new GainNode(this.context, { gain: 100 });\n  this.detuneGain.connect(this.audioNode.detune);\n}\n\nprivate registerInputs() {\n  this.registerAudioInput({\n    name: \"detune\",\n    getAudioNode: () => this.detuneGain,\n  });\n}\n"}]}],"\n",["$","h2",null,{"children":"Implement rePlug functionality"}],"\n",["$","p",null,{"children":["Unfortunately, we haven't finished yet with the oscillator.\nAs we discussed in the previous post, every time we stop the oscillator, we have to generate a new ",["$","code",null,{"children":"OscillatorNode"}]," to start it again.\nThis means we need to build a replug mechanism that will allow us to replug all the connected I/Os."]}],"\n",["$","h3",null,{"children":"Oscillator"}],"\n",["$","p",null,{"children":"I'll start by explaining how I'd like to use the replug mechanism.\nWe want a function that will accept a callback, so internally we will unplug all I/Os, run the desired code, and then replug the I/Os."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/modules/Oscillator.ts\nstop(time: number) {\n  this.audioNode.stop(time);\n  this.rePlugAll(() => {\n    this.audioNode = new OscillatorNode(this.context, {\n      type: this.props[\"wave\"],\n      frequency: this.props[\"frequency\"],\n    });\n  });\n\n  this.isStated = false;\n}\n"}]}],"\n",["$","h3",null,{"children":"Base Module"}],"\n",["$","p",null,{"children":"The implementation of the rePlugAll mechanism in the base module is simple, as we just delegate the functionality to the input/output collection."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/Module.ts\nprotected rePlugAll(callback?: () => void) {\n  this.inputs.rePlugAll(callback);\n  this.outputs.rePlugAll(callback);\n}\n"}]}],"\n",["$","h3",null,{"children":"Collection"}],"\n",["$","p",null,{"children":"The collection again delegates the functionality to each I/O."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/Collection.ts\nrePlugAll(callback?: () => void) {\n  this.collection.forEach((io) => io.rePlugAll(callback));\n}\n"}]}],"\n",["$","h3",null,{"children":"Base I/O"}],"\n",["$","p",null,{"children":"Finally, we will implement the actual replug functionality in the Base I/O.\nWe keep the connected I/Os in a variable, so we can unplug them, call the callback, and then replug all the connections."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/IO/Base.ts\nrePlugAll(callback?: () => void) {\n  const connections = this.connections;\n  this.unPlugAll();\n  if (callback) callback();\n\n  connections.forEach((otherIO) => this.plug(otherIO));\n}\n\nunPlugAll() {\n  this.connections.forEach((otherIO) => this.unPlug(otherIO));\n}\n"}]}],"\n",["$","h2",null,{"children":"Routes"}],"\n",["$","p",null,{"children":["We have integrated our I/O system into the modules, so it's time to expose it to the engine.\nWe will create a ",["$","code",null,{"children":"Routes"}]," class responsible for keeping route information and providing the API that will be exposed to the engine, allowing us to add and remove routes."]}],"\n",["$","h3",null,{"children":"Implementation"}],"\n",["$","p",null,{"children":"We discussed in the beginning how a route data looks."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"{\n  id: string,\n  source: { ioName: string, moduleId: string },\n  destination: { ioName: string, moduleId: string }\n}\n"}]}],"\n",["$","p",null,{"children":"This will be translated to a TypeScript interface like this:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/core/Routes.ts\ninterface IPlug {\n  moduleId: string;\n  ioName: string;\n}\n\ninterface IRoute {\n  id: string;\n  source: IPlug;\n  destination: IPlug;\n}\n"}]}],"\n",["$","p",null,{"children":["I'll provide the whole code at once as it is relatively simple.\nIn the constructor of the class, we pass the engine so we can find the desired modules from it and, more specifically, the desired I/O of a module.\nWe keep the information of the routes in an object where the key is the id of the route and the value is the ",["$","code",null,{"children":"IRoute"}],".\nThe only available public functions will be ",["$","code",null,{"children":"addRoute"}]," and ",["$","code",null,{"children":"removeRoute"}],"."]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"$2"}]}],"\n",["$","p",null,{"children":["We also have to implement the ",["$","code",null,{"children":"findIO"}]," function as it doesn't exist yet."]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/Engine.ts\nfindIO(moduleId: string, ioName: string, type: \"input\" | \"output\") {\n  const module = this.findModule(moduleId);\n  return module[`${type}s`].findByName(ioName);\n}\n"}]}],"\n",["$","h3",null,{"children":"Expose to Engine"}],"\n",["$","p",null,{"children":["Finally, we need to integrate ",["$","code",null,{"children":"Routes"}]," into the engine and expose ",["$","code",null,{"children":"addRoute"}]," and ",["$","code",null,{"children":"removeRoute"}],"."]}],"\n",["$","p",null,{"children":"We start by defining the routes property in the engine:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/Engine.ts\nroutes: Routes;\n"}]}],"\n",["$","p",null,{"children":"Initialize it in the constructor:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/Engine.ts\n// function: constructor\nthis.routes = new Routes(this);\n"}]}],"\n",["$","p",null,{"children":["And then expose the ",["$","code",null,{"children":"addRoute"}]," and ",["$","code",null,{"children":"removeRoute"}]," methods:"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"// file: /src/Engine.ts\naddRoute(props: Optional<IRoute, \"id\">) {\n  this.routes.addRoute(props);\n}\n\nremoteRoute(id: string) {\n  this.routes.removeRoute(id);\n}\n"}]}],"\n",["$","h2",null,{"children":"Lets Have Some Fun!"}],"\n",["$","p",null,{"children":"I'll write a very simple example of code that creates a routing from an oscillator -> volume -> master.\nAdditionally, I'll create an LFO, which is actually an oscillator, that will be connected to oscillator detune."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-ts","children":"import { Engine, ModuleType } from \"blibliki\";\n\nconst context = new AudioContext();\nconst engine = new Engine(context);\n\nconst osc = engine.addModule({\n  name: \"osc\",\n  moduleType: ModuleType.Oscillator,\n  props: { wave: \"sine\", frequency: 440 },\n});\n\nconst lfo = engine.addModule({\n  name: \"osc\",\n  moduleType: ModuleType.Oscillator,\n  props: { wave: \"sine\", frequency: 2 },\n});\n\nconst vol = engine.addModule({\n  name: \"vol\",\n  moduleType: ModuleType.Volume,\n  props: { volume: 0.01 },\n});\n\nconst master = engine.addModule({\n  name: \"master\",\n  moduleType: ModuleType.Master,\n  props: {},\n});\n\nengine.addRoute({\n  source: { moduleId: osc.id, ioName: \"out\" },\n  destination: { moduleId: vol.id, ioName: \"in\" },\n});\nengine.addRoute({\n  source: { moduleId: lfo.id, ioName: \"out\" },\n  destination: { moduleId: osc.id, ioName: \"detune\" },\n});\nengine.addRoute({\n  source: { moduleId: vol.id, ioName: \"out\" },\n  destination: { moduleId: master.id, ioName: \"in\" },\n});\n\nawait engine.start();\n"}]}],"\n",["$","$L3",null,{}],"\n",["$","p",null,{"children":"Now, I'm challenging you to create a crazy patch, and believe it, it's possible even though we have very limited modules for now."}],"\n",["$","h2",null,{"children":"Before Close"}],"\n",["$","p",null,{"children":"If you made the effort to read this post, please leave a comment or contact me. It is really important to me to hear your feedback."}],"\n",["$","h2",null,{"children":"What's Next"}],"\n",["$","p",null,{"children":"In the next post, we will implement MIDI I/O, which will allow us to pass MIDI events to the modules that need them and handle these events based on the needs of each module."}]],null]]},["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children","web-audio-engine-part4","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},[null,["$","$L6",null,{"children":["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],"params":{}}],null]]},[null,["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__className_f367f3 flex min-h-screen flex-col","children":[["$","header",null,{"className":"container flex items-center justify-between py-4 dark:bg-gray-800","children":[["$","h1",null,{"className":"text-xl font-semibold text-gray-900 dark:text-white","children":["$","$L7",null,{"href":"/","children":"Mike Zaby"}]}],["$","nav",null,{"children":["$","ul",null,{"className":"flex space-x-4","children":[["$","li",null,{"children":["$","a",null,{"target":"_blank","href":"https://github.com/mikezaby","className":"transition-colors hover:text-gray-600 dark:hover:text-white","children":["$","svg",null,{"viewBox":"0 0 16 16","className":"h-5 w-5","fill":"currentColor","aria-hidden":"true","children":["$","path",null,{"d":"M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"}]}]}]}],["$","li",null,{"children":["$","a",null,{"target":"_blank","href":"https://twitter.com/mikezaby","className":"transition-colors hover:text-blue-500","children":["$","svg",null,{"viewBox":"0 0 24 24","className":"h-5 w-5","fill":"currentColor","aria-hidden":"true","children":["$","path",null,{"d":"M24 4.557c-.883.392-1.832.656-2.828.775 1.017-.609 1.798-1.574 2.165-2.724-.951.564-2.005.974-3.127 1.195-.897-.957-2.178-1.555-3.594-1.555-3.179 0-5.515 2.966-4.797 6.045-4.091-.205-7.719-2.165-10.148-5.144-1.29 2.213-.669 5.108 1.523 6.574-.806-.026-1.566-.247-2.229-.616-.054 2.281 1.581 4.415 3.949 4.89-.693.188-1.452.232-2.224.084.626 1.956 2.444 3.379 4.6 3.419-2.07 1.623-4.678 2.348-7.29 2.04 2.179 1.397 4.768 2.212 7.548 2.212 9.142 0 14.307-7.721 13.995-14.646.962-.695 1.797-1.562 2.457-2.549z"}]}]}]}],["$","li",null,{"children":["$","a",null,{"target":"_blank","href":"https://youtube.com/@mizakiro","className":"transition-colors hover:text-red-600","children":["$","svg",null,{"viewBox":"0 0 24 24","className":"h-5 w-5","fill":"currentColor","aria-hidden":"true","children":["$","path",null,{"d":"M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"}]}]}]}],["$","li",null,{"children":["$","a",null,{"target":"_blank","href":"https://www.linkedin.com/in/michalis-zabaras-97b5002b","className":"transition-colors hover:text-blue-700","children":["$","svg",null,{"viewBox":"0 0 24 24","className":"h-5 w-5","fill":"currentColor","aria-hidden":"true","children":["$","path",null,{"d":"M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"}]}]}]}],["$","li",null,{"children":["$","$L7",null,{"href":"/about","className":"font-bold transition-colors hover:text-gray-600 dark:hover:text-white","children":"About"}]}]]}]}]]}],["$","div",null,{"className":"separator"}],["$","main",null,{"className":"container mt-8 flex-grow","children":["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/bdde1bbfab0e1ea2.css","precedence":"next","crossOrigin":""}]]}]}],["$","footer",null,{"className":"container py-8 text-center","children":["$","p",null,{"className":"text-gray-600 dark:text-gray-300","children":"Â© 2024 Michalis Zabaras. All rights reserved."}]}]]}]}],null]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/5ed5fb0a340729e2.css","precedence":"next","crossOrigin":""}]],"$L8"]]]]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Web Audio Engine Part 4 - Implementing Advanced I/O"}],["$","meta","3",{"name":"description","content":"In this post, we explore how to implement an advanced I/O system for our web audio engine. We'll set up modular inputs and outputs, integrate them into the engine, and create a routing mechanism"}],["$","meta","4",{"name":"next-size-adjust"}]]
1:null
