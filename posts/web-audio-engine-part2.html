<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/29a689f93ca1686d.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/c95096fc0885ed51.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-f284b8a5be8f2dd8.js" crossorigin=""/><script src="/_next/static/chunks/90234aad-5159adccd7e3436a.js" async="" crossorigin=""></script><script src="/_next/static/chunks/672-b73124050f5d0e39.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-cdb975597a421eb2.js" async="" crossorigin=""></script><script src="/_next/static/chunks/139-b73d5ea002175980.js" async=""></script><script src="/_next/static/chunks/app/posts/web-audio-engine-part2/page-c4b26bf3d3a016ee.js" async=""></script><script src="/_next/static/chunks/254-17354c19cb10c525.js" async=""></script><script src="/_next/static/chunks/313-7b5fed2341bd8540.js" async=""></script><script src="/_next/static/chunks/app/posts/layout-b25b02d9cfe42cb0.js" async=""></script><script src="/_next/static/chunks/app/page-3850038a3bfc23e2.js" async=""></script><title>Web Audio Engine Part 2 - Shaping the Core of Our Modular Audio Engine</title><meta name="description" content="In this part we will explore the file and data structure of the engine, and how to manage modules (create, update, remove)"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body class="__className_aaf875 flex min-h-screen flex-col"><header class="container flex items-center justify-between py-4 dark:bg-gray-800"><h1 class="text-xl font-semibold text-gray-900 dark:text-white"><a href="/">Mike Zaby</a></h1><nav><ul class="flex space-x-4"><li><a target="_blank" href="https://github.com/mikezaby" class="transition-colors hover:text-gray-600 dark:hover:text-white"><svg viewBox="0 0 16 16" class="h-5 w-5" fill="currentColor" aria-hidden="true"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg></a></li><li><a target="_blank" href="https://twitter.com/mikezaby" class="transition-colors hover:text-blue-500"><svg viewBox="0 0 24 24" class="h-5 w-5" fill="currentColor" aria-hidden="true"><path d="M24 4.557c-.883.392-1.832.656-2.828.775 1.017-.609 1.798-1.574 2.165-2.724-.951.564-2.005.974-3.127 1.195-.897-.957-2.178-1.555-3.594-1.555-3.179 0-5.515 2.966-4.797 6.045-4.091-.205-7.719-2.165-10.148-5.144-1.29 2.213-.669 5.108 1.523 6.574-.806-.026-1.566-.247-2.229-.616-.054 2.281 1.581 4.415 3.949 4.89-.693.188-1.452.232-2.224.084.626 1.956 2.444 3.379 4.6 3.419-2.07 1.623-4.678 2.348-7.29 2.04 2.179 1.397 4.768 2.212 7.548 2.212 9.142 0 14.307-7.721 13.995-14.646.962-.695 1.797-1.562 2.457-2.549z"></path></svg></a></li><li><a target="_blank" href="https://youtube.com/@mizakiro" class="transition-colors hover:text-red-600"><svg viewBox="0 0 24 24" class="h-5 w-5" fill="currentColor" aria-hidden="true"><path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"></path></svg></a></li><li><a target="_blank" href="https://www.linkedin.com/in/michalis-zabaras-97b5002b" class="transition-colors hover:text-blue-700"><svg viewBox="0 0 24 24" class="h-5 w-5" fill="currentColor" aria-hidden="true"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"></path></svg></a></li><li><a class="font-bold transition-colors hover:text-gray-600 dark:hover:text-white" href="/about">About</a></li></ul></nav></header><div class="separator"></div><main class="container mt-8 flex-grow"><div><article class="markdown-body"><h1>Web Audio Engine Part 2 - Shaping the Core of Our Modular Audio Engine</h1>
<h2>Recap</h2>
<p>In the <a href="/posts/web-audio-engine-part1">previous post</a>, we explored the fundamental ideas behind the engine, discussing its core functionality and the API at a high level.
In this post, we will define the file and data structure of the project, setting the stage for us to systematically develop our features, one by one.
The first feature we will tackle is module management, which includes the ability to create, update, and remove modules.</p>
<h2>But what is a module</h2>
<p>We can think of modules like small functions that have the capability to be chained together.
For example, consider a string generator function where we perform some string manipulation afterward:</p>
<pre><code class="language-js">function stringGenerator() {
  return &quot;  My modular synthesizer   &quot;;
}
stringGenerator().trim().toUpperCase();
// Expected output: &quot;MY MODULAR SYNTHESIZER&quot;
</code></pre>
<p>In the context of modular synthesizers, let&#x27;s imagine we have an oscillator as a generator module that produces a sine wave signal, with its signal values ranging between the minimum and maximum (-1 to 1).</p>
<img loading="lazy" width="1979" height="580" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/sinewave.41c1feb7.jpg"/>
<p>Next, we might want to apply a gain to this signal, amplifying it by 5, which results in an adjusted waveform.</p>
<img loading="lazy" width="1979" height="580" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/sinewave_mult.8f0d6cb9.jpg"/>
<p>Modules have inputs and outputs to achieve this. Here is a visualization of the modules from our previous example.</p>
<img loading="lazy" width="1596" height="642" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/sinewave_mult_diagram.6a4e9e1c.png"/>
<p>Our engine supports two kinds of I/O: Audio and MIDI.
We will elaborate more about IO in the next post.</p>
<p>Let&#x27;s preview some modules that we will implement in our Engine:</p>
<p>Audio:</p>
<ul>
<li>Generator, generates audio signal<!-- -->
<ul>
<li>Oscillator, it generates sound of sine, triangle, square waves in a desired frequency</li>
</ul>
</li>
<li>Processing<!-- -->
<ul>
<li>Volume, it adjust the loudness of the input signal</li>
<li>Filter, it applies frequency filtering to the input signal</li>
</ul>
</li>
</ul>
<p>Midi:</p>
<ul>
<li>Sequencer, it generates midi events over time</li>
</ul>
<h2>Preparing for development</h2>
<p>At the beginning, we want to shape our project and figure out how to create, update, or remove a module.
While we&#x27;re not going to work with audio at this step, it is a very important one because we will structure the foundation of this library, see how data flows through the modules, and prepare our code for the next steps.</p>
<h2>File Structure</h2>
<p>This is what our file structure will look like at the end of this post:</p>
<pre><code>- src
  - index.ts
  - Engine.ts
  - core
    - index.ts
    - Module.ts
  - modules
    - index.ts
    - Oscillator.ts
    - Volume.ts
    - Master.ts
</code></pre>
<p>Lets explain this files and folders.</p>
<p><code>Engine.ts</code> exposes all the functionality that are available for the engine users.</p>
<p>The <code>core</code> folder is where we place various functionalities that our modules will use.
Under the <code>core</code> folder, there is a file named <code>Module.ts</code>.
This is an abstract class that captures the essence of modules and is inherited by all the modules.</p>
<p>The modules folder contains all of our specific module implementations.</p>
<h2>Data Structure</h2>
<p>We want to make the minimum required data structure that will describe our modules and their current state.
This includes the following fields:</p>
<ul>
<li>id, uuidv4</li>
<li>name, to help us organize our modules</li>
<li>moduleType, the module type (Oscillator, Volume, etc.)</li>
<li>props, each module type, has it own props, for example the Oscillator has frequency and wave, and the Volume has volume.</li>
</ul>
<p>Here is how looks like:</p>
<pre><code class="language-ts">{
  id: string,
  name: string,
  type: ModuleType,
  props: Object,
}
</code></pre>
<h2>Module management:</h2>
<p>This section outlines how users are expected to interact with the engine.</p>
<ul>
<li>Add module</li>
</ul>
<pre><code class="language-ts">const volume = Engine.addModule({
  name: &quot;Vol&quot;,
  type: &quot;Volume&quot;,
  props: { volume: -10 },
});
const osc = Engine.addModule({
  name: &quot;Osc&quot;,
  type: &quot;Oscillator&quot;,
  props: { wave: &quot;sine&quot;, frequency: 440 },
});
</code></pre>
<ul>
<li>Update module</li>
</ul>
<pre><code class="language-ts">const volume = Engine.updateModule({
  id: 1
  changes: { props: { volume: -10 } },
});
</code></pre>
<ul>
<li>Remove module</li>
</ul>
<pre><code class="language-ts">Engine.removeModule(1);
</code></pre>
<h2>The Base Module class</h2>
<p>Having discussed the engine&#x27;s concept, file and data structures, and how users can manage modules, it&#x27;s time to dive deeper into the code and examine our implementation of the abstract Module class.</p>
<p>Previously, we outlined a data structure capable of serving every module we build, with the flexibility of the props attribute.
However, our goal is to have a polymorphic data structure that is also type-safe.</p>
<pre><code class="language-ts">enum ModuleType {
  Oscillator = &quot;Oscillator&quot;,
  Volume = &quot;Volume&quot;,
}

interface ModuleTypeToPropsMapping {
  [ModuleType.Oscillator]: IOscillatorProps;
  [ModuleType.Volume]: IVolumeProps;
}

interface IModule&lt;T extends ModuleType&gt; {
  id: string;
  name: string;
  moduleType: T;
  props: ModuleTypeToPropsMapping[T];
}
</code></pre>
<p>As shown above, we start by defining the ModuleType enum, then map the type to actual module props.
This approach achieves a polymorphic data structure through the use of a ModuleType generic.</p>
<p>To fully understand this concept, let&#x27;s examine the data structures for Oscillator and Volume:</p>
<pre><code class="language-ts">interface IOscillatorProps {
  wave: OscillatorType;
  frequency: number;
}

interface IOscillator extends IModule&lt;ModuleType.Oscillator&gt; {}
</code></pre>
<pre><code class="language-ts">interface IVolumeProps {
  volume: number;
}

interface IVolume extends IModule&lt;ModuleType.Volume&gt; {}
</code></pre>
<p>Next, we will start implementating the abstract Module class.
To support our data-driven approach, we need to implement two functions, props and serialize:</p>
<ul>
<li>props: We define getter and setter functions. The getter returns the module&#x27;s <code>props</code>, and the setter accepts a Partial of props, allowing updates to all or specific props.</li>
<li>serialize: This function returns the instance&#x27;s data, structured according to the <code>IModule</code>.</li>
</ul>
<pre><code class="language-ts">abstract class Module&lt;T extends ModuleType&gt; implements IModule&lt;T&gt; {
  id: string;
  name: string;
  moduleType: T;
  protected _props!: ModuleTypeToPropsMapping[T];

  constructor(params: Optional&lt;IModule&lt;T&gt;, &quot;id&quot;&gt;) {
    const { id, name, moduleType, props } = params;

    this.id = id || uuidv4();
    this.name = name;
    this.moduleType = moduleType;
    this._props = {} as ModuleTypeToPropsMapping[T];
    this.props = props;
  }

  get props(): ModuleTypeToPropsMapping[T] {
    return this._props;
  }

  set props(value: Partial&lt;ModuleTypeToPropsMapping[T]&gt;) {
    this._props = { ...this._props, ...value };
  }

  serialize(): IModule&lt;T&gt; {
    return {
      id: this.id,
      name: this.name,
      moduleType: this.moduleType,
      props: this.props,
    };
  }
}
</code></pre>
<p>Two additional points need clarification, as they were not mentioned earlier: <code>Optional</code> and <code>uuidv4</code>.</p>
<p><code>uuidv4</code> comes from the <code>uuid</code> package.</p>
<p><code>Optional</code> is a helper type that allows us to make one or more properties of an interface optional.
We have defined this under <code>utils/types</code>.</p>
<pre><code class="language-ts">type Optional&lt;T, K extends keyof T&gt; = Partial&lt;Pick&lt;T, K&gt;&gt; &amp; Omit&lt;T, K&gt;;
</code></pre>
<h2>The Modules</h2>
<p>The modules will inherit from <code>core/Module</code> and implement the additional functionality each one requires.
For the moment, we will implement only the Oscillator and Volume modules.
Given the data structures we defined earlier, their implementation at this stage is relatively straightforward.</p>
<pre><code class="language-ts">const DEFAULT_PROPS: IOscillatorProps = { wave: &quot;sine&quot;, frequency: 440 };

class Oscillator extends Module&lt;ModuleType.Oscillator&gt; {
  constructor(params: IChildParams&lt;ModuleType.Oscillator&gt;) {
    const props = { ...DEFAULT_PROPS, ...params.props };
    super({ ...params, props, moduleType: ModuleType.Oscillator });
  }
}
</code></pre>
<pre><code class="language-ts">const DEFAULT_PROPS: IVolumeProps = { volume: 100 };

class Volume extends Module&lt;ModuleType.Volume&gt; {
  constructor(params: IChildParams&lt;ModuleType.Volume&gt;) {
    const props = { ...DEFAULT_PROPS, ...params.props };
    super({ ...params, props, moduleType: ModuleType.Volume });
  }
}
</code></pre>
<p>The <code>IChildParams</code> interface serves as a helper so that we don’t need to redefine similar interfaces for the constructor parameters of the modules repeatedly.</p>
<pre><code class="language-ts">interface IChildParams&lt;T extends ModuleType&gt; {
  id?: string;
  name: string;
  props: Partial&lt;ModuleTypeToPropsMapping[T]&gt;;
}
</code></pre>
<h2>The Engine</h2>
<p>Having implemented almost everything needed at this step, we are now ready to implement the Engine.
We will define the Engine as a singleton, with its only current property being the modules.</p>
<pre><code class="language-ts">import { Module, ModuleType } from &quot;./core&quot;;

class Engine {
  private static instance: Engine;

  modules: {
    [Identifier: string]: Module&lt;ModuleType&gt;;
  };

  public static getInstance(): Engine {
    if (!Engine.instance) {
      Engine.instance = new Engine();
    }

    return Engine.instance;
  }

  constructor() {
    this.modules = {};
  }
}

export default Engine.getInstance();
</code></pre>
<p>With the Engine set up, we can now implement module management functions.</p>
<h3>addModule</h3>
<p>This function creates modules and returns the serialized data of the module, as we intend to expose only the data to users.</p>
<pre><code class="language-ts">addModule&lt;T extends ModuleType&gt;(params: ICreateParams) {
  const module = createModule(params);
  this.modules[module.id] = module;

  return module.serialize() as IModule&lt;T&gt;;
}
</code></pre>
<p>Usage:</p>
<pre><code class="language-ts">const osc = Engine.addModule&lt;ModuleType.Oscillator&gt;({
  name: &quot;Osc&quot;,
  type: &quot;Oscillator&quot;,
  props: { wave: &quot;sine&quot;, frequency: 440 },
});
</code></pre>
<p>We use <code>createModule</code> and <code>ICreateParams</code> that be taken from <code>modules/index</code>
This setup ensures params match with the module type.</p>
<pre><code class="language-ts">interface ICreateModule&lt;T extends ModuleType&gt; extends IChildParams&lt;T&gt; {
  moduleType: T;
}

type ICreateParams =
  | ICreateModule&lt;ModuleType.Oscillator&gt;
  | ICreateModule&lt;ModuleType.Volume&gt;;

function createModule(params: ICreateParams): AnyModule {
  switch (params.moduleType) {
    case ModuleType.Oscillator:
      return new Oscillator(params);
    case ModuleType.Volume:
      return new Volume(params);
    default:
      throw Error(`Unknown moduleType ${params.moduleType}`);
  }
}
</code></pre>
<h3>updateModule</h3>
<p>First, define the function parameters interface:</p>
<pre><code class="language-ts">interface IUpdateModule&lt;T extends ModuleType&gt; {
  id: string;
  moduleType: T;
  changes: Partial&lt;Omit&lt;IChildParams&lt;T&gt;, &quot;id&quot;&gt;&gt;;
}
</code></pre>
<p>This approach ensures that we find the module to which the changes apply and maintain only the name and props changes.
While TypeScript provides a level of type safety, accommodating potential use from JavaScript or type misuse helps make our package more robust.</p>
<pre><code class="language-ts">updateModule&lt;T extends ModuleType&gt;(params: IUpdateModule&lt;T&gt;) {
  const module = this.findModule(params.id);
  if (module.moduleType !== params.moduleType) {
    throw Error(
      `The module id ${params.id} isn&#x27;t moduleType ${params.moduleType}`,
    );
  }

  const updates = pick(params.changes, [&quot;name&quot;, &quot;props&quot;]);
  Object.assign(module, updates);

  return module.serialize() as IModule&lt;T&gt;;
}

findModule(id: string) {
  const module = this.modules[id];
  if (!module) throw Error(`Module ${id} not found`)
}
</code></pre>
<p>Usage:</p>
<pre><code class="language-ts">const osc = Engine.addModule&lt;ModuleType.Oscillator&gt;({
  id: 1,
  type: &quot;Oscillator&quot;,
  changes: { props: { frequency: 880 } },
});
</code></pre>
<h3>removeModule</h3>
<pre><code class="language-ts">removeModule(id: string) {
  delete this.modules[id];
}

</code></pre>
<h2>Repository</h2>
<p>There is a repository containing the code we&#x27;ve discussed here, which I&#x27;m developing alongside writing this series of posts.
The goal is to create a branch for each post. This way, you can explore the entire codebase and grasp the project&#x27;s scope without being overwhelmed by code not yet covered.</p>
<p>You can find the branch related to this post here: <a href="https://github.com/mikezaby/bliblik_raw_engine/tree/basic-module">https://github.com/mikezaby/bliblik_raw_engine/tree/basic-module</a></p>
<h2>What&#x27;s Next</h2>
<p>In the next post we will start intergrating WebAudio starting from AudioNode, and we will explore how we could connect modules between them.</p></article><div id="disqus_thread"></div></div></main><footer class="container py-8 text-center"><p class="text-gray-600 dark:text-gray-300">© 2024 Michalis Zabaras. All rights reserved.</p></footer><script src="/_next/static/chunks/webpack-f284b8a5be8f2dd8.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/29a689f93ca1686d.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L3\"\n"])</script><script>self.__next_f.push([1,"4:HL[\"/_next/static/css/c95096fc0885ed51.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"5:I[7732,[],\"\"]\n7:I[8139,[\"139\",\"static/chunks/139-b73d5ea002175980.js\",\"764\",\"static/chunks/app/posts/web-audio-engine-part2/page-c4b26bf3d3a016ee.js\"],\"Image\"]\n8:I[3107,[],\"\"]\n9:I[6865,[],\"\"]\na:I[6088,[\"139\",\"static/chunks/139-b73d5ea002175980.js\",\"254\",\"static/chunks/254-17354c19cb10c525.js\",\"313\",\"static/chunks/313-7b5fed2341bd8540.js\",\"517\",\"static/chunks/app/posts/layout-b25b02d9cfe42cb0.js\"],\"\"]\nb:I[9254,[\"139\",\"static/chunks/139-b73d5ea002175980.js\",\"254\",\"static/chunks/254-17354c19cb10c525.js\",\"931\",\"static/chunks/app/page-3850038a3bfc23e2.js\"],\"\"]\nd:I[8022,[],\"\"]\ne:[]\n"])</script><script>self.__next_f.push([1,"3:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/29a689f93ca1686d.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"sg_z5A8SqMZ-s3o-LMp_3\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/posts/web-audio-engine-part2\",\"initialTree\":[\"\",{\"children\":[\"posts\",{\"children\":[\"web-audio-engine-part2\",{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"posts\",{\"children\":[\"web-audio-engine-part2\",{\"children\":[\"__PAGE__\",{},[\"$L6\",[[\"$\",\"h1\",null,{\"children\":\"Web Audio Engine Part 2 - Shaping the Core of Our Modular Audio Engine\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Recap\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"In the \",[\"$\",\"a\",null,{\"href\":\"/posts/web-audio-engine-part1\",\"children\":\"previous post\"}],\", we explored the fundamental ideas behind the engine, discussing its core functionality and the API at a high level.\\nIn this post, we will define the file and data structure of the project, setting the stage for us to systematically develop our features, one by one.\\nThe first feature we will tackle is module management, which includes the ability to create, update, and remove modules.\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"But what is a module\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"We can think of modules like small functions that have the capability to be chained together.\\nFor example, consider a string generator function where we perform some string manipulation afterward:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function stringGenerator() {\\n  return \\\"  My modular synthesizer   \\\";\\n}\\nstringGenerator().trim().toUpperCase();\\n// Expected output: \\\"MY MODULAR SYNTHESIZER\\\"\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In the context of modular synthesizers, let's imagine we have an oscillator as a generator module that produces a sine wave signal, with its signal values ranging between the minimum and maximum (-1 to 1).\"}],\"\\n\",[\"$\",\"$L7\",null,{\"src\":{\"src\":\"/_next/static/media/sinewave.41c1feb7.jpg\",\"height\":580,\"width\":1979,\"blurDataURL\":\"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoKCgoKCgsMDAsPEA4QDxYUExMUFiIYGhgaGCIzICUgICUgMy03LCksNy1RQDg4QFFeT0pPXnFlZXGPiI+7u/sBCgoKCgoKCwwMCw8QDhAPFhQTExQWIhgaGBoYIjMgJSAgJSAzLTcsKSw3LVFAODhAUV5PSk9ecWVlcY+Ij7u7+//CABEIAAIACAMBIgACEQEDEQH/xAAnAAEBAAAAAAAAAAAAAAAAAAAABwEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAAsQP/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/9oACAEBAAE/AH//xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oACAECAQE/AH//xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oACAEDAQE/AH//2Q==\",\"blurWidth\":8,\"blurHeight\":2},\"alt\":\"$undefined\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Next, we might want to apply a gain to this signal, amplifying it by 5, which results in an adjusted waveform.\"}],\"\\n\",[\"$\",\"$L7\",null,{\"src\":{\"src\":\"/_next/static/media/sinewave_mult.8f0d6cb9.jpg\",\"height\":580,\"width\":1979,\"blurDataURL\":\"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoKCgoKCgsMDAsPEA4QDxYUExMUFiIYGhgaGCIzICUgICUgMy03LCksNy1RQDg4QFFeT0pPXnFlZXGPiI+7u/sBCgoKCgoKCwwMCw8QDhAPFhQTExQWIhgaGBoYIjMgJSAgJSAzLTcsKSw3LVFAODhAUV5PSk9ecWVlcY+Ij7u7+//CABEIAAIACAMBIgACEQEDEQH/xAAnAAEBAAAAAAAAAAAAAAAAAAAABwEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAAsYP/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/9oACAEBAAE/AH//xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oACAECAQE/AH//xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oACAEDAQE/AH//2Q==\",\"blurWidth\":8,\"blurHeight\":2},\"alt\":\"$undefined\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Modules have inputs and outputs to achieve this. Here is a visualization of the modules from our previous example.\"}],\"\\n\",[\"$\",\"$L7\",null,{\"src\":{\"src\":\"/_next/static/media/sinewave_mult_diagram.6a4e9e1c.png\",\"height\":642,\"width\":1596,\"blurDataURL\":\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAAAAACLoxGUAAAAIElEQVR42g3CgQkAMAzDsPx/8CjEHq1QBFpM38wlVuG7PZ4XiWMT1q8AAAAASUVORK5CYII=\",\"blurWidth\":8,\"blurHeight\":3},\"alt\":\"$undefined\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Our engine supports two kinds of I/O: Audio and MIDI.\\nWe will elaborate more about IO in the next post.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Let's preview some modules that we will implement in our Engine:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Audio:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Generator, generates audio signal\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Oscillator, it generates sound of sine, triangle, square waves in a desired frequency\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Processing\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Volume, it adjust the loudness of the input signal\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Filter, it applies frequency filtering to the input signal\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Midi:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Sequencer, it generates midi events over time\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Preparing for development\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"At the beginning, we want to shape our project and figure out how to create, update, or remove a module.\\nWhile we're not going to work with audio at this step, it is a very important one because we will structure the foundation of this library, see how data flows through the modules, and prepare our code for the next steps.\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"File Structure\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This is what our file structure will look like at the end of this post:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"- src\\n  - index.ts\\n  - Engine.ts\\n  - core\\n    - index.ts\\n    - Module.ts\\n  - modules\\n    - index.ts\\n    - Oscillator.ts\\n    - Volume.ts\\n    - Master.ts\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Lets explain this files and folders.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"Engine.ts\"}],\" exposes all the functionality that are available for the engine users.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The \",[\"$\",\"code\",null,{\"children\":\"core\"}],\" folder is where we place various functionalities that our modules will use.\\nUnder the \",[\"$\",\"code\",null,{\"children\":\"core\"}],\" folder, there is a file named \",[\"$\",\"code\",null,{\"children\":\"Module.ts\"}],\".\\nThis is an abstract class that captures the essence of modules and is inherited by all the modules.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The modules folder contains all of our specific module implementations.\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Data Structure\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"We want to make the minimum required data structure that will describe our modules and their current state.\\nThis includes the following fields:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"id, uuidv4\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"name, to help us organize our modules\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"moduleType, the module type (Oscillator, Volume, etc.)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"props, each module type, has it own props, for example the Oscillator has frequency and wave, and the Volume has volume.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Here is how looks like:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"{\\n  id: string,\\n  name: string,\\n  type: ModuleType,\\n  props: Object,\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Module management:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This section outlines how users are expected to interact with the engine.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Add module\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"const volume = Engine.addModule({\\n  name: \\\"Vol\\\",\\n  type: \\\"Volume\\\",\\n  props: { volume: -10 },\\n});\\nconst osc = Engine.addModule({\\n  name: \\\"Osc\\\",\\n  type: \\\"Oscillator\\\",\\n  props: { wave: \\\"sine\\\", frequency: 440 },\\n});\\n\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Update module\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"const volume = Engine.updateModule({\\n  id: 1\\n  changes: { props: { volume: -10 } },\\n});\\n\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Remove module\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"Engine.removeModule(1);\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"The Base Module class\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Having discussed the engine's concept, file and data structures, and how users can manage modules, it's time to dive deeper into the code and examine our implementation of the abstract Module class.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Previously, we outlined a data structure capable of serving every module we build, with the flexibility of the props attribute.\\nHowever, our goal is to have a polymorphic data structure that is also type-safe.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"enum ModuleType {\\n  Oscillator = \\\"Oscillator\\\",\\n  Volume = \\\"Volume\\\",\\n}\\n\\ninterface ModuleTypeToPropsMapping {\\n  [ModuleType.Oscillator]: IOscillatorProps;\\n  [ModuleType.Volume]: IVolumeProps;\\n}\\n\\ninterface IModule\u003cT extends ModuleType\u003e {\\n  id: string;\\n  name: string;\\n  moduleType: T;\\n  props: ModuleTypeToPropsMapping[T];\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"As shown above, we start by defining the ModuleType enum, then map the type to actual module props.\\nThis approach achieves a polymorphic data structure through the use of a ModuleType generic.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"To fully understand this concept, let's examine the data structures for Oscillator and Volume:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"interface IOscillatorProps {\\n  wave: OscillatorType;\\n  frequency: number;\\n}\\n\\ninterface IOscillator extends IModule\u003cModuleType.Oscillator\u003e {}\\n\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"interface IVolumeProps {\\n  volume: number;\\n}\\n\\ninterface IVolume extends IModule\u003cModuleType.Volume\u003e {}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Next, we will start implementating the abstract Module class.\\nTo support our data-driven approach, we need to implement two functions, props and serialize:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"props: We define getter and setter functions. The getter returns the module's \",[\"$\",\"code\",null,{\"children\":\"props\"}],\", and the setter accepts a Partial of props, allowing updates to all or specific props.\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"serialize: This function returns the instance's data, structured according to the \",[\"$\",\"code\",null,{\"children\":\"IModule\"}],\".\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"abstract class Module\u003cT extends ModuleType\u003e implements IModule\u003cT\u003e {\\n  id: string;\\n  name: string;\\n  moduleType: T;\\n  protected _props!: ModuleTypeToPropsMapping[T];\\n\\n  constructor(params: Optional\u003cIModule\u003cT\u003e, \\\"id\\\"\u003e) {\\n    const { id, name, moduleType, props } = params;\\n\\n    this.id = id || uuidv4();\\n    this.name = name;\\n    this.moduleType = moduleType;\\n    this._props = {} as ModuleTypeToPropsMapping[T];\\n    this.props = props;\\n  }\\n\\n  get props(): ModuleTypeToPropsMapping[T] {\\n    return this._props;\\n  }\\n\\n  set props(value: Partial\u003cModuleTypeToPropsMapping[T]\u003e) {\\n    this._props = { ...this._props, ...value };\\n  }\\n\\n  serialize(): IModule\u003cT\u003e {\\n    return {\\n      id: this.id,\\n      name: this.name,\\n      moduleType: this.moduleType,\\n      props: this.props,\\n    };\\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Two additional points need clarification, as they were not mentioned earlier: \",[\"$\",\"code\",null,{\"children\":\"Optional\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"uuidv4\"}],\".\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"uuidv4\"}],\" comes from the \",[\"$\",\"code\",null,{\"children\":\"uuid\"}],\" package.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"Optional\"}],\" is a helper type that allows us to make one or more properties of an interface optional.\\nWe have defined this under \",[\"$\",\"code\",null,{\"children\":\"utils/types\"}],\".\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"type Optional\u003cT, K extends keyof T\u003e = Partial\u003cPick\u003cT, K\u003e\u003e \u0026 Omit\u003cT, K\u003e;\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"The Modules\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The modules will inherit from \",[\"$\",\"code\",null,{\"children\":\"core/Module\"}],\" and implement the additional functionality each one requires.\\nFor the moment, we will implement only the Oscillator and Volume modules.\\nGiven the data structures we defined earlier, their implementation at this stage is relatively straightforward.\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"const DEFAULT_PROPS: IOscillatorProps = { wave: \\\"sine\\\", frequency: 440 };\\n\\nclass Oscillator extends Module\u003cModuleType.Oscillator\u003e {\\n  constructor(params: IChildParams\u003cModuleType.Oscillator\u003e) {\\n    const props = { ...DEFAULT_PROPS, ...params.props };\\n    super({ ...params, props, moduleType: ModuleType.Oscillator });\\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"const DEFAULT_PROPS: IVolumeProps = { volume: 100 };\\n\\nclass Volume extends Module\u003cModuleType.Volume\u003e {\\n  constructor(params: IChildParams\u003cModuleType.Volume\u003e) {\\n    const props = { ...DEFAULT_PROPS, ...params.props };\\n    super({ ...params, props, moduleType: ModuleType.Volume });\\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The \",[\"$\",\"code\",null,{\"children\":\"IChildParams\"}],\" interface serves as a helper so that we don’t need to redefine similar interfaces for the constructor parameters of the modules repeatedly.\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"interface IChildParams\u003cT extends ModuleType\u003e {\\n  id?: string;\\n  name: string;\\n  props: Partial\u003cModuleTypeToPropsMapping[T]\u003e;\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"The Engine\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Having implemented almost everything needed at this step, we are now ready to implement the Engine.\\nWe will define the Engine as a singleton, with its only current property being the modules.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"import { Module, ModuleType } from \\\"./core\\\";\\n\\nclass Engine {\\n  private static instance: Engine;\\n\\n  modules: {\\n    [Identifier: string]: Module\u003cModuleType\u003e;\\n  };\\n\\n  public static getInstance(): Engine {\\n    if (!Engine.instance) {\\n      Engine.instance = new Engine();\\n    }\\n\\n    return Engine.instance;\\n  }\\n\\n  constructor() {\\n    this.modules = {};\\n  }\\n}\\n\\nexport default Engine.getInstance();\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"With the Engine set up, we can now implement module management functions.\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"addModule\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This function creates modules and returns the serialized data of the module, as we intend to expose only the data to users.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"addModule\u003cT extends ModuleType\u003e(params: ICreateParams) {\\n  const module = createModule(params);\\n  this.modules[module.id] = module;\\n\\n  return module.serialize() as IModule\u003cT\u003e;\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Usage:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"const osc = Engine.addModule\u003cModuleType.Oscillator\u003e({\\n  name: \\\"Osc\\\",\\n  type: \\\"Oscillator\\\",\\n  props: { wave: \\\"sine\\\", frequency: 440 },\\n});\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"We use \",[\"$\",\"code\",null,{\"children\":\"createModule\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"ICreateParams\"}],\" that be taken from \",[\"$\",\"code\",null,{\"children\":\"modules/index\"}],\"\\nThis setup ensures params match with the module type.\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"interface ICreateModule\u003cT extends ModuleType\u003e extends IChildParams\u003cT\u003e {\\n  moduleType: T;\\n}\\n\\ntype ICreateParams =\\n  | ICreateModule\u003cModuleType.Oscillator\u003e\\n  | ICreateModule\u003cModuleType.Volume\u003e;\\n\\nfunction createModule(params: ICreateParams): AnyModule {\\n  switch (params.moduleType) {\\n    case ModuleType.Oscillator:\\n      return new Oscillator(params);\\n    case ModuleType.Volume:\\n      return new Volume(params);\\n    default:\\n      throw Error(`Unknown moduleType ${params.moduleType}`);\\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"updateModule\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"First, define the function parameters interface:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"interface IUpdateModule\u003cT extends ModuleType\u003e {\\n  id: string;\\n  moduleType: T;\\n  changes: Partial\u003cOmit\u003cIChildParams\u003cT\u003e, \\\"id\\\"\u003e\u003e;\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This approach ensures that we find the module to which the changes apply and maintain only the name and props changes.\\nWhile TypeScript provides a level of type safety, accommodating potential use from JavaScript or type misuse helps make our package more robust.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"updateModule\u003cT extends ModuleType\u003e(params: IUpdateModule\u003cT\u003e) {\\n  const module = this.findModule(params.id);\\n  if (module.moduleType !== params.moduleType) {\\n    throw Error(\\n      `The module id ${params.id} isn't moduleType ${params.moduleType}`,\\n    );\\n  }\\n\\n  const updates = pick(params.changes, [\\\"name\\\", \\\"props\\\"]);\\n  Object.assign(module, updates);\\n\\n  return module.serialize() as IModule\u003cT\u003e;\\n}\\n\\nfindModule(id: string) {\\n  const module = this.modules[id];\\n  if (!module) throw Error(`Module ${id} not found`)\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Usage:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"const osc = Engine.addModule\u003cModuleType.Oscillator\u003e({\\n  id: 1,\\n  type: \\\"Oscillator\\\",\\n  changes: { props: { frequency: 880 } },\\n});\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"removeModule\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"removeModule(id: string) {\\n  delete this.modules[id];\\n}\\n\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Repository\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"There is a repository containing the code we've discussed here, which I'm developing alongside writing this series of posts.\\nThe goal is to create a branch for each post. This way, you can explore the entire codebase and grasp the project's scope without being overwhelmed by code not yet covered.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"You can find the branch related to this post here: \",[\"$\",\"a\",null,{\"href\":\"https://github.com/mikezaby/bliblik_raw_engine/tree/basic-module\",\"children\":\"https://github.com/mikezaby/bliblik_raw_engine/tree/basic-module\"}]]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"What's Next\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In the next post we will start intergrating WebAudio starting from AudioNode, and we will explore how we could connect modules between them.\"}]],null]]},[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\",\"web-audio-engine-part2\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[null,[\"$\",\"$La\",null,{\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],\"params\":{}}],null]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_aaf875 flex min-h-screen flex-col\",\"children\":[[\"$\",\"header\",null,{\"className\":\"container flex items-center justify-between py-4 dark:bg-gray-800\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-xl font-semibold text-gray-900 dark:text-white\",\"children\":[\"$\",\"$Lb\",null,{\"href\":\"/\",\"children\":\"Mike Zaby\"}]}],[\"$\",\"nav\",null,{\"children\":[\"$\",\"ul\",null,{\"className\":\"flex space-x-4\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"target\":\"_blank\",\"href\":\"https://github.com/mikezaby\",\"className\":\"transition-colors hover:text-gray-600 dark:hover:text-white\",\"children\":[\"$\",\"svg\",null,{\"viewBox\":\"0 0 16 16\",\"className\":\"h-5 w-5\",\"fill\":\"currentColor\",\"aria-hidden\":\"true\",\"children\":[\"$\",\"path\",null,{\"d\":\"M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z\"}]}]}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"target\":\"_blank\",\"href\":\"https://twitter.com/mikezaby\",\"className\":\"transition-colors hover:text-blue-500\",\"children\":[\"$\",\"svg\",null,{\"viewBox\":\"0 0 24 24\",\"className\":\"h-5 w-5\",\"fill\":\"currentColor\",\"aria-hidden\":\"true\",\"children\":[\"$\",\"path\",null,{\"d\":\"M24 4.557c-.883.392-1.832.656-2.828.775 1.017-.609 1.798-1.574 2.165-2.724-.951.564-2.005.974-3.127 1.195-.897-.957-2.178-1.555-3.594-1.555-3.179 0-5.515 2.966-4.797 6.045-4.091-.205-7.719-2.165-10.148-5.144-1.29 2.213-.669 5.108 1.523 6.574-.806-.026-1.566-.247-2.229-.616-.054 2.281 1.581 4.415 3.949 4.89-.693.188-1.452.232-2.224.084.626 1.956 2.444 3.379 4.6 3.419-2.07 1.623-4.678 2.348-7.29 2.04 2.179 1.397 4.768 2.212 7.548 2.212 9.142 0 14.307-7.721 13.995-14.646.962-.695 1.797-1.562 2.457-2.549z\"}]}]}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"target\":\"_blank\",\"href\":\"https://youtube.com/@mizakiro\",\"className\":\"transition-colors hover:text-red-600\",\"children\":[\"$\",\"svg\",null,{\"viewBox\":\"0 0 24 24\",\"className\":\"h-5 w-5\",\"fill\":\"currentColor\",\"aria-hidden\":\"true\",\"children\":[\"$\",\"path\",null,{\"d\":\"M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z\"}]}]}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"target\":\"_blank\",\"href\":\"https://www.linkedin.com/in/michalis-zabaras-97b5002b\",\"className\":\"transition-colors hover:text-blue-700\",\"children\":[\"$\",\"svg\",null,{\"viewBox\":\"0 0 24 24\",\"className\":\"h-5 w-5\",\"fill\":\"currentColor\",\"aria-hidden\":\"true\",\"children\":[\"$\",\"path\",null,{\"d\":\"M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z\"}]}]}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"$Lb\",null,{\"href\":\"/about\",\"className\":\"font-bold transition-colors hover:text-gray-600 dark:hover:text-white\",\"children\":\"About\"}]}]]}]}]]}],[\"$\",\"div\",null,{\"className\":\"separator\"}],[\"$\",\"main\",null,{\"className\":\"container mt-8 flex-grow\",\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/c95096fc0885ed51.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]}],[\"$\",\"footer\",null,{\"className\":\"container py-8 text-center\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-gray-600 dark:text-gray-300\",\"children\":\"© 2024 Michalis Zabaras. All rights reserved.\"}]}]]}]}],null]],\"initialHead\":[false,\"$Lc\"],\"globalErrorComponent\":\"$d\",\"missingSlots\":\"$We\"}]]\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Web Audio Engine Part 2 - Shaping the Core of Our Modular Audio Engine\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"In this part we will explore the file and data structure of the engine, and how to manage modules (create, update, remove)\"}],[\"$\",\"meta\",\"4\",{\"name\":\"next-size-adjust\"}]]\n6:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>