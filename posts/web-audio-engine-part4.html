<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/29242e86bbe0719e.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/c95096fc0885ed51.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-65b272b162965a52.js" crossorigin=""/><script src="/_next/static/chunks/90234aad-94b9601bc92ba32c.js" async="" crossorigin=""></script><script src="/_next/static/chunks/672-712a286b3b50ffb9.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-cdb975597a421eb2.js" async="" crossorigin=""></script><script src="/_next/static/chunks/139-49b50a3bf6f25794.js" async=""></script><script src="/_next/static/chunks/254-700dd0f479925ac0.js" async=""></script><script src="/_next/static/chunks/313-3c66015e67682b11.js" async=""></script><script src="/_next/static/chunks/app/posts/layout-3c2a5579c52700c6.js" async=""></script><script src="/_next/static/chunks/53dc2434-cbba9649805a64e5.js" async=""></script><script src="/_next/static/chunks/app/page-6102fbb40167a089.js" async=""></script><title>Web Audio Engine Part 4 - Implementing Advanced I/O</title><meta name="description" content="In this post, we explore how to implement an advanced I/O system for our web audio engine. We&#x27;ll set up modular inputs and outputs, integrate them into the engine, and create a routing mechanism"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body class="__className_aaf875 flex min-h-screen flex-col"><header class="container flex items-center justify-between py-4 dark:bg-gray-800"><h1 class="text-xl font-semibold text-gray-900 dark:text-white"><a href="/">Mike Zaby</a></h1><nav><ul class="flex space-x-4"><li><a target="_blank" href="https://github.com/mikezaby" class="transition-colors hover:text-gray-600 dark:hover:text-white"><svg viewBox="0 0 16 16" class="h-5 w-5" fill="currentColor" aria-hidden="true"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg></a></li><li><a target="_blank" href="https://twitter.com/mikezaby" class="transition-colors hover:text-blue-500"><svg viewBox="0 0 24 24" class="h-5 w-5" fill="currentColor" aria-hidden="true"><path d="M24 4.557c-.883.392-1.832.656-2.828.775 1.017-.609 1.798-1.574 2.165-2.724-.951.564-2.005.974-3.127 1.195-.897-.957-2.178-1.555-3.594-1.555-3.179 0-5.515 2.966-4.797 6.045-4.091-.205-7.719-2.165-10.148-5.144-1.29 2.213-.669 5.108 1.523 6.574-.806-.026-1.566-.247-2.229-.616-.054 2.281 1.581 4.415 3.949 4.89-.693.188-1.452.232-2.224.084.626 1.956 2.444 3.379 4.6 3.419-2.07 1.623-4.678 2.348-7.29 2.04 2.179 1.397 4.768 2.212 7.548 2.212 9.142 0 14.307-7.721 13.995-14.646.962-.695 1.797-1.562 2.457-2.549z"></path></svg></a></li><li><a target="_blank" href="https://youtube.com/@mizakiro" class="transition-colors hover:text-red-600"><svg viewBox="0 0 24 24" class="h-5 w-5" fill="currentColor" aria-hidden="true"><path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"></path></svg></a></li><li><a target="_blank" href="https://www.linkedin.com/in/michalis-zabaras-97b5002b" class="transition-colors hover:text-blue-700"><svg viewBox="0 0 24 24" class="h-5 w-5" fill="currentColor" aria-hidden="true"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"></path></svg></a></li><li><a class="font-bold transition-colors hover:text-gray-600 dark:hover:text-white" href="/about">About</a></li></ul></nav></header><div class="separator"></div><main class="container mt-8 flex-grow"><div><article class="markdown-body"><h1>Web Audio Engine Part 4 - implementing Advanced I/O</h1>
<p>In the <a href="/posts/web-audio-engine-part3">previous post</a>, we began integrating Web Audio and implemented a basic connect functionality, allowing us to link modules together.
However, this basic functionality has limitations when it comes to building more complex audio systems. It lacks the flexibility and control needed for advanced audio processing tasks.</p>
<p>To overcome these limitations, in this post, we will explore and implement a more advanced and modular I/O system.
This new system will provide greater control over connections, enabling us to create more intricate and scalable audio setups.
Additionally, this enhanced I/O system will offer users detailed information about the available I/Os of a module and the current connections between these I/Os.</p>
<p>Before we continue I&#x27;m suggesting to do a fast diagonal reading if you have already read it before, or a more detailed reading if you haven&#x27;t to
<a href="/posts/web-audio-engine-part1">part1</a>,
<a href="/posts/web-audio-engine-part2">part2</a>,
<a href="/posts/web-audio-engine-part3">part3</a>.</p>
<p>You can find the codebase up to this point on the <a href="https://github.com/mikezaby/web_audio_engine/tree/advanced-io">advanced-io</a> branch,
or you can view the additions compared with the previous post <a href="https://github.com/mikezaby/web_audio_engine/compare/audio-node...advanced-io">here</a>.</p>
<h2>Data Structure</h2>
<p>We will start with the data structure.</p>
<p>First, let&#x27;s describe the data structure of an I/O:</p>
<pre><code class="language-ts">{
  id: string,
  name: string,
  ioType: IOType,
  moduleId: string,
}
</code></pre>
<p>The <code>IOType</code> will keep all the available I/O types that we will implement.
In this post, we will implement <code>AudioInput</code> and <code>AudioOutput</code>, but in the next iteration, we will add support for <code>MidiInput</code> and <code>MidiOutput</code>.</p>
<pre><code class="language-ts">// file: /src/core/IO/Base.ts
enum IOType {
  AudioInput = &quot;audioInput&quot;,
  AudioOutput = &quot;audioOutput&quot;,
}
</code></pre>
<p>Next, we want to define the data structure that describes the connection between an input and an output.
We name this connection a <code>Route</code>.</p>
<pre><code class="language-ts">{
  id: string,
  source: { ioName: string, moduleId: string },
  destination: { ioName: string, moduleId: string }
}
</code></pre>
<p>We decided to use <code>ioName</code> and <code>moduleId</code> as the information for the source and destination instead of just the I/O id.
This decision allows us to quickly determine which module an I/O belongs to, and using ioName instead of an id makes it more human-friendly.
We also enforce unique name validation to avoid problems with duplicate names.</p>
<p>So this information is enough to know which I/Os are available and the connections between them.</p>
<h2>File Structure</h2>
<p>In this post, we will implement the <code>Base</code> class for our I/O, the <code>AudioIO</code>, which will handle the connections between <code>AudioNode</code> outputs and <code>AudioNode</code> inputs or <code>AudioParams</code>.
Additionally, we will implement a collection that will help us define easily the desired inputs and outputs for each module.</p>
<pre><code>- src
  - core
    - IO
      - index.ts
      - Base.ts
      - AudioIO.ts
      - Collection.ts
</code></pre>
<h2>The Base IO Class</h2>
<p>We want to define the interface for the I/O based on the data that we showed before.
To initialize an I/O, we need to know the name of the I/O and its type.</p>
<pre><code class="language-ts">// file: /src/core/IO/Base.ts
interface IOProps {
  name: string;
  ioType: IOType;
}
</code></pre>
<p>For serialization, we need to extend the previous interface with the information of I/O id and moduleId.</p>
<pre><code class="language-ts">// file: /src/core/IO/Base.ts
interface IIOSerialize extends IOProps {
  id: string;
  moduleId: string;
}
</code></pre>
<h3>Constructor</h3>
<p>To define an I/O, we also need to know which module it belongs to, for this reason, we pass this argument in the constructor.
We use a deterministic id generation based on module id and I/O name.
We do this because we want unique ids, but we also want the ability to reproduce the same id when we have the same module id and I/O name.
Lastly, we want to keep track of the connections of this I/O.</p>
<pre><code class="language-ts">// file: /src/core/IO/Base.ts
abstract class Base implements IOProps {
  id: string;
  ioType: IOType;
  name: string;
  module: AnyModule;
  connections: Base[];

  constructor(module: AnyModule, props: IOProps) {
    this.module = module;
    this.name = props.name;
    this.ioType = props.ioType;
    this.id = deterministicId(this.module.id, this.name);
    this.connections = [];
  }
}
</code></pre>
<h3>Plug/UnPlug</h3>
<p>We want a standardized procedure for any I/O type that can be plugged or unplugged, and these functions can be overridden with extra logic based on specific I/O type needs.
The only thing that we want from basic plug/unplug functionality is to update the connections.
Also, because we want both input and output informed about the connection, we have a flag to know if we need to call the plug/unPlug function in the opposite way.
We also have an unPlugAll functionality to easily unplug all connections.</p>
<pre><code class="language-ts">// file: /src/core/IO/Base.ts
plug(io: Base, plugOther: boolean = true) {
  this.connections.push(io);
  if (plugOther) io.plug(this, false);
}

unPlug(io: Base, plugOther: boolean = true) {
  this.connections = this.connections.filter(
    (currentIO) =&gt; currentIO.id !== io.id,
  );
  if (plugOther) io.unPlug(this, false);
}

unPlugAll() {
  this.connections.forEach((otherIO) =&gt; this.unPlug(otherIO));
}
</code></pre>
<h3>Serialize</h3>
<p>We want to serialize the data of the I/O based on what we discussed in the <strong>Data Structure</strong> section.</p>
<pre><code class="language-ts">// file: /src/core/IO/Base.ts
serialize(): IIOSerialize {
  return {
    id: this.id,
    name: this.name,
    ioType: this.ioType,
    moduleId: this.module.id,
  };
}
</code></pre>
<h3>Handling Connection As Geneneric</h3>
<p>In some cases may we don&#x27;t want to change to plug/unPlug anything else than what is the <code>Connection</code>,
so we make an aditional class that will extends <code>Base</code> with the ability to set a generic about the <code>Connection</code>.</p>
<pre><code class="language-ts">// file: /src/core/IO/Base.ts
abstract class IO&lt;Connection extends Base&gt; extends Base {
  declare connections: Connection[];

  constructor(module: AnyModule, props: IOProps) {
    super(module, props);
  }

  plug(io: Connection, plugOther?: boolean): void {
    super.plug(io, plugOther);
  }

  unPlug(io: Connection, plugOther?: boolean): void {
    super.unPlug(io, plugOther);
  }
}
</code></pre>
<h2>AudioIO</h2>
<p>We want to adjust <code>IOProps</code> to set specific types for <code>AudioInputProps</code> and <code>AudioOutputProps</code>, and extend them with an extra field <code>getAudioNode</code>, which is a callback that returns an <code>AudioNode</code> for output, as only the AudioNode has the ability to call connect.
For inputs, the callback returns an <code>AudioNode</code>, <code>AudioParam</code>, or <code>AudioDestinationNode</code> because all of this are able to be connected to an AudioNode.
We use a callback instead of a simple property because the AudioNode may change.
For example, with an Oscillator, we have to create a new OscillatorNode every time we stop it.</p>
<pre><code class="language-ts">// file: /src/core/IO/AudioIO.ts
export interface AudioInputProps extends IOProps {
  ioType: IOType.AudioInput;
  getAudioNode: () =&gt; AudioNode | AudioParam | AudioDestinationNode;
}

export interface AudioOutputProps extends IOProps {
  ioType: IOType.AudioOutput;
  getAudioNode: () =&gt; AudioNode;
}
</code></pre>
<p>The implementation of <code>AudioInput</code> is straightforward:</p>
<pre><code class="language-ts">// file: /src/core/IO/AudioIO.ts
class AudioInput extends IO&lt;AudioOutput&gt; implements AudioInputProps {
  declare ioType: IOType.AudioInput;
  getAudioNode: AudioInputProps[&quot;getAudioNode&quot;];

  constructor(module: AnyModule, props: AudioInputProps) {
    super(module, props);
    this.getAudioNode = props.getAudioNode;
  }
}
</code></pre>
<p>In the <code>AudioOutput</code>, we will add the extra code that should be executed when we plug or unplug.</p>
<pre><code class="language-ts">// file: /src/core/IO/AudioIO.ts
export class AudioOutput extends IO&lt;AudioInput&gt; implements AudioOutputProps {
  declare ioType: IOType.AudioOutput;
  getAudioNode!: AudioOutputProps[&quot;getAudioNode&quot;];

  constructor(module: AnyModule, props: AudioOutputProps) {
    super(module, props);
    this.getAudioNode = props.getAudioNode;
  }

  plug(io: AudioInput, plugOther: boolean = true) {
    super.plug(io, plugOther);
    const input = io.getAudioNode();

    if (input instanceof AudioParam) {
      this.getAudioNode().connect(input);
    } else {
      this.getAudioNode().connect(input);
    }
  }

  unPlug(io: AudioInput, plugOther: boolean = true) {
    super.unPlug(io, plugOther);
    const input = io.getAudioNode();

    try {
      if (input instanceof AudioParam) {
        this.getAudioNode().disconnect(input);
      } else {
        this.getAudioNode().disconnect(input);
      }
    } catch (e) {
      console.error(e);
    }
  }
}
</code></pre>
<p>Unfortunately, we have an awkward handling to connect an <code>AudioNode</code> to an <code>AudioParam</code>.
While the connect method allows connecting an <code>AudioNode</code> to an <code>AudioParam</code>, due to a TypeScript <a href="https://github.com/microsoft/TypeScript/issues/14107">issue</a>, we have to handle it like this.</p>
<h2>Collection</h2>
<p>The last tool for I/O will be the <code>Collection</code>.
We want the integration to be as easy as possible and ensure proper separation of concerns.
Therefore, we need a class that will serve as a collection of Inputs or Outputs and handle tasks such as adding a new I/O, finding an existing one, and serializing the collection.</p>
<p>As mentioned, we want two collection types: Input and Output.
Currently, we have only one type of Node for each collection type.</p>
<pre><code class="language-ts">// file: /src/core/IO/Collection.ts
enum CollectionType {
  Input = &quot;Input&quot;,
  Output = &quot;Output&quot;,
}
</code></pre>
<h3>Constructor</h3>
<p>We need a class that will take a generic type representing the <code>CollectionType</code>.
We will use this generic type later to match properties appropriately based on the collection type.</p>
<pre><code class="language-ts">// file: /src/core/IO/Collection.ts
abstract class IOCollection&lt;T extends CollectionType&gt; {
  module: AnyModule;
  collection: Base[] = [];
  collectionType: T;

  constructor(collectionType: T, module: AnyModule) {
    this.collectionType = collectionType;
    this.module = module;
  }
}
</code></pre>
<h3>Add I/O</h3>
<p>We want to create an interface that will map the appropriate properties based on the collection type.
This allows us to avoid incorrect usage at an early stage through type checking.
Finally, we need to validate the uniqueness of the I/O name in this collection.</p>
<pre><code class="language-ts">// file: /src/core/IO/Collection.ts
interface IMappedIOProps {
  [CollectionType.Input]: AudioInputProps;
  [CollectionType.Output]: AudioOutputProps;
}
</code></pre>
<pre><code class="language-ts">// file: /src/core/IO/Collection.ts
add(props: IMappedIOProps[T]) {
  let io: Base;
  this.validateUniqName(props.name);

  switch (props.ioType) {
    case IOType.AudioInput:
      io = new AudioInput(this.module, props);
      break;
    case IOType.AudioOutput:
      io = new AudioOutput(this.module, props);
      break;
    default:
      assertNever(props);
  }

  this.collection.push(io);

  return io;
}
</code></pre>
<pre><code class="language-ts">// file: /src/core/IO/Collection.ts
private validateUniqName(name: string) {
  if (this.collection.some((io) =&gt; io.name === name)) {
    throw Error(`An I/O with name ${name} already exists`);
  }
}
</code></pre>
<h3>Finders And Serializer</h3>
<p>These functions are straightforward:</p>
<pre><code class="language-ts">// file: /src/core/IO/Collection.ts
find(id: string) {
  const io = this.collection.find((io) =&gt; io.id === id);
  if (!io) throw Error(`The I/O with id ${id} does not exists`);

  return io;
}

findByName(name: string) {
  const io = this.collection.find((io) =&gt; io.name === name);
  if (!io) throw Error(`The I/O with name ${name} does not exists`);

  return io;
}

serialize() {
  return this.collection.map((io) =&gt; io.serialize());
}
</code></pre>
<h3>Input/OutputCollection</h3>
<p>To facilitate easier usage in the module, we expose <code>InputCollection</code> and <code>OutputCollection</code>:</p>
<pre><code class="language-ts">// file: /src/core/IO/Collection.ts
export class InputCollection extends IOCollection&lt;CollectionType.Input&gt; {
  constructor(module: AnyModule) {
    super(CollectionType.Input, module);
  }
}

export class OutputCollection extends IOCollection&lt;CollectionType.Output&gt; {
  constructor(module: AnyModule) {
    super(CollectionType.Output, module);
  }
}
</code></pre>
<h2>Base Module Integration</h2>
<p>In the Base module constructor, we initialize Input/OutputCollection:</p>
<pre><code class="language-ts">// file: /src/core/Module.ts
// function: constructor
this.inputs = new InputCollection(this);
this.outputs = new OutputCollection(this);
</code></pre>
<p>Then we want to provide an easy way to define audio inputs/outputs:</p>
<pre><code class="language-ts">// file: /src/core/Module.ts
protected registerAudioInput(props: Omit&lt;AudioInputProps, &quot;ioType&quot;&gt;) {
  this.inputs.add({ ...props, ioType: IOType.AudioInput });
}

protected registerAudioOutput(props: Omit&lt;AudioOutputProps, &quot;ioType&quot;&gt;) {
  this.outputs.add({ ...props, ioType: IOType.AudioOutput });
}
</code></pre>
<p>We will see the usage of this as we also want to give the ability to define some common I/Os.
The most common case is to define the module&#x27;s main input and output <code>AudioNode</code>.</p>
<pre><code class="language-ts">// file: /src/core/Module.ts
protected registerDefaultIOs(value: &quot;both&quot; | &quot;in&quot; | &quot;out&quot; = &quot;both&quot;) {
  if (value === &quot;in&quot; || value === &quot;both&quot;) {
    this.registerAudioInput({
      name: &quot;in&quot;,
      getAudioNode: () =&gt; this.audioNode,
    });
  }

  if (value === &quot;out&quot; || value === &quot;both&quot;) {
    this.registerAudioOutput({
      name: &quot;out&quot;,
      getAudioNode: () =&gt; this.audioNode,
    });
  }
}
</code></pre>
<p>We also want to add information about the available I/Os to the serialize function:</p>
<pre><code class="language-ts">// file: /src/core/Module.ts
interface IModuleSerialize&lt;T extends ModuleType&gt; extends IModule&lt;T&gt; {
  inputs: IIOSerialize[];
  outputs: IIOSerialize[];
}
</code></pre>
<pre><code class="language-ts">// file: /src/core/Module.ts
serialize(): IModuleSerialize&lt;T&gt; {
  return {
    id: this.id,
    name: this.name,
    moduleType: this.moduleType,
    props: this.props,
    inputs: this.inputs.serialize(),
    outputs: this.outputs.serialize(),
  };
}
</code></pre>
<h2>Define I/Os To Available Modules</h2>
<p>Now we are ready to define the I/Os for the actual modules.</p>
<h3>Volume</h3>
<p>The volume module has both an input and an output, as we connect a signal to its input and take the adjusted signal from its output.
So, we will define both input and output.</p>
<pre><code class="language-ts">// file: /src/modules/Volume.ts
// function: constructor
this.registerDefaultIOs();
</code></pre>
<h3>Master</h3>
<p>The master module has only an input, which allows any module to reach our audio interface.</p>
<pre><code class="language-ts">// file: /src/modules/Master.ts
// function: constructor
this.registerDefaultIOs(&quot;in&quot;);
</code></pre>
<h3>Oscillator</h3>
<p>Conversely, the oscillator has only an output, as the oscillator generates the signal.</p>
<pre><code class="language-ts">// file: /src/modules/Oscillator.ts
// function: constructor

this.initializeGainDetune();
this.registerDefaultIOs(&quot;out&quot;);
this.registerInputs();
</code></pre>
<p>However, we will define an input for the <code>detune</code> <code>AudioParam</code>.
With this setup, we allow the ability to automatically mutate the frequency.
For example, we can connect another oscillator to detune.</p>
<p>The <code>OscillatorNode.detune</code> parameter changes the original frequency by one semitone for every 100 cents.
We want to apply values from -1 to 1 to change the original frequency by one semitone.
Therefore, we create an extra <code>GainNode</code> with a value of 100, connect it to <code>audioNode.detune</code>, and then expose the <code>detuneGain</code> instead of <code>audioNode.detune</code>.</p>
<pre><code class="language-ts">// file: /src/modules/Oscillator.ts
private initializeGainDetune() {
  this.detuneGain = new GainNode(this.context, { gain: 100 });
  this.detuneGain.connect(this.audioNode.detune);
}

private registerInputs() {
  this.registerAudioInput({
    name: &quot;detune&quot;,
    getAudioNode: () =&gt; this.detuneGain,
  });
}
</code></pre>
<h2>Implement rePlug functionality</h2>
<p>Unfortunately, we haven&#x27;t finished yet with the oscillator.
As we discussed in the previous post, every time we stop the oscillator, we have to generate a new <code>OscillatorNode</code> to start it again.
This means we need to build a replug mechanism that will allow us to replug all the connected I/Os.</p>
<h3>Oscillator</h3>
<p>I&#x27;ll start by explaining how I&#x27;d like to use the replug mechanism.
We want a function that will accept a callback, so internally we will unplug all I/Os, run the desired code, and then replug the I/Os.</p>
<pre><code class="language-ts">// file: /src/modules/Oscillator.ts
stop(time: number) {
  this.audioNode.stop(time);
  this.rePlugAll(() =&gt; {
    this.audioNode = new OscillatorNode(this.context, {
      type: this.props[&quot;wave&quot;],
      frequency: this.props[&quot;frequency&quot;],
    });
  });

  this.isStated = false;
}
</code></pre>
<h3>Base Module</h3>
<p>The implementation of the rePlugAll mechanism in the base module is simple, as we just delegate the functionality to the input/output collection.</p>
<pre><code class="language-ts">// file: /src/core/Module.ts
protected rePlugAll(callback?: () =&gt; void) {
  this.inputs.rePlugAll(callback);
  this.outputs.rePlugAll(callback);
}
</code></pre>
<h3>Collection</h3>
<p>The collection again delegates the functionality to each I/O.</p>
<pre><code class="language-ts">// file: /src/core/IO/Collection.ts
rePlugAll(callback?: () =&gt; void) {
  this.collection.forEach((io) =&gt; io.rePlugAll(callback));
}
</code></pre>
<h3>Base I/O</h3>
<p>Finally, we will implement the actual replug functionality in the Base I/O.
We keep the connected I/Os in a variable, so we can unplug them, call the callback, and then replug all the connections.</p>
<pre><code class="language-ts">// file: /src/core/IO/Base.ts
rePlugAll(callback?: () =&gt; void) {
  const connections = this.connections;
  this.unPlugAll();
  if (callback) callback();

  connections.forEach((otherIO) =&gt; this.plug(otherIO));
}

unPlugAll() {
  this.connections.forEach((otherIO) =&gt; this.unPlug(otherIO));
}
</code></pre>
<h2>Routes</h2>
<p>We have integrated our I/O system into the modules, so it&#x27;s time to expose it to the engine.
We will create a <code>Routes</code> class responsible for keeping route information and providing the API that will be exposed to the engine, allowing us to add and remove routes.</p>
<h3>Implementation</h3>
<p>We discussed in the beginning how a route data looks.</p>
<pre><code class="language-ts">{
  id: string,
  source: { ioName: string, moduleId: string },
  destination: { ioName: string, moduleId: string }
}
</code></pre>
<p>This will be translated to a TypeScript interface like this:</p>
<pre><code class="language-ts">// file: /src/core/Routes.ts
interface IPlug {
  moduleId: string;
  ioName: string;
}

interface IRoute {
  id: string;
  source: IPlug;
  destination: IPlug;
}
</code></pre>
<p>I&#x27;ll provide the whole code at once as it is relatively simple.
In the constructor of the class, we pass the engine so we can find the desired modules from it and, more specifically, the desired I/O of a module.
We keep the information of the routes in an object where the key is the id of the route and the value is the <code>IRoute</code>.
The only available public functions will be <code>addRoute</code> and <code>removeRoute</code>.</p>
<pre><code class="language-ts">// file: /src/core/Routes.ts
export class Routes {
  engine: Engine;
  routes: { [key: string]: IRoute };

  constructor(engine: Engine) {
    this.engine = engine;
    this.routes = {};
  }

  addRoute(props: Optional&lt;IRoute, &quot;id&quot;&gt;) {
    const id = props.id || uuidv4();
    this.routes[id] = { ...props, id };

    this.plug(id);
  }

  removeRoute(id: string) {
    this.unPlug(id);
    delete this.routes[id];
  }

  private plug(id: string) {
    const { sourceIO, destinationIO } = this.getIOs(id);
    sourceIO.plug(destinationIO);
  }

  private unPlug(id: string) {
    const { sourceIO, destinationIO } = this.getIOs(id);
    sourceIO.unPlug(destinationIO);
  }

  private find(id: string): IRoute {
    if (!this.routes[id]) throw Error(`Route with id ${id} not found`);

    return this.routes[id];
  }

  private getIOs(id: string) {
    const route = this.find(id);
    const { source, destination } = route;

    const sourceIO = this.engine.findIO(
      source.moduleId,
      source.ioName,
      &quot;output&quot;,
    );
    const destinationIO = this.engine.findIO(
      destination.moduleId,
      destination.ioName,
      &quot;input&quot;,
    );

    return { sourceIO, destinationIO };
  }
}
</code></pre>
<p>We also have to implement the <code>findIO</code> function as it doesn&#x27;t exist yet.</p>
<pre><code class="language-ts">// file: /src/Engine.ts
findIO(moduleId: string, ioName: string, type: &quot;input&quot; | &quot;output&quot;) {
  const module = this.findModule(moduleId);
  return module[`${type}s`].findByName(ioName);
}
</code></pre>
<h3>Expose to Engine</h3>
<p>Finally, we need to integrate <code>Routes</code> into the engine and expose <code>addRoute</code> and <code>removeRoute</code>.</p>
<p>We start by defining the routes property in the engine:</p>
<pre><code class="language-ts">// file: /src/Engine.ts
routes: Routes;
</code></pre>
<p>Initialize it in the constructor:</p>
<pre><code class="language-ts">// file: /src/Engine.ts
// function: constructor
this.routes = new Routes(this);
</code></pre>
<p>And then expose the <code>addRoute</code> and <code>removeRoute</code> methods:</p>
<pre><code class="language-ts">// file: /src/Engine.ts
addRoute(props: Optional&lt;IRoute, &quot;id&quot;&gt;) {
  this.routes.addRoute(props);
}

remoteRoute(id: string) {
  this.routes.removeRoute(id);
}
</code></pre>
<h2>Lets Have Some Fun!</h2>
<p>I&#x27;ll write a very simple example of code that creates a routing from an oscillator -&gt; volume -&gt; master.
Additionally, I&#x27;ll create an LFO, which is actually an oscillator, that will be connected to oscillator detune.</p>
<pre><code class="language-ts">import { Engine, ModuleType } from &quot;blibliki&quot;;

const context = new AudioContext();
const engine = new Engine(context);

const osc = engine.addModule({
  name: &quot;osc&quot;,
  moduleType: ModuleType.Oscillator,
  props: { wave: &quot;sine&quot;, frequency: 440 },
});

const lfo = engine.addModule({
  name: &quot;osc&quot;,
  moduleType: ModuleType.Oscillator,
  props: { wave: &quot;sine&quot;, frequency: 2 },
});

const vol = engine.addModule({
  name: &quot;vol&quot;,
  moduleType: ModuleType.Volume,
  props: { volume: 0.01 },
});

const master = engine.addModule({
  name: &quot;master&quot;,
  moduleType: ModuleType.Master,
  props: {},
});

engine.addRoute({
  source: { moduleId: osc.id, ioName: &quot;out&quot; },
  destination: { moduleId: vol.id, ioName: &quot;in&quot; },
});
engine.addRoute({
  source: { moduleId: lfo.id, ioName: &quot;out&quot; },
  destination: { moduleId: osc.id, ioName: &quot;detune&quot; },
});
engine.addRoute({
  source: { moduleId: vol.id, ioName: &quot;out&quot; },
  destination: { moduleId: master.id, ioName: &quot;in&quot; },
});

await engine.start();
</code></pre>
<p>Now, I&#x27;m challenging you to create a crazy patch, and believe it, it&#x27;s possible even though we have very limited modules for now.</p>
<h2>Before Close</h2>
<p>If you made the effort to read this post, please leave a comment or contact me. It is really important to me to hear your feedback.</p>
<h2>what&#x27;s next</h2>
<p>I don&#x27;t know yet what Part 5 will be about, but I know for sure that sooner or later, I&#x27;ll write the next part!</p></article><div id="disqus_thread"></div></div></main><footer class="container py-8 text-center"><p class="text-gray-600 dark:text-gray-300">Â© 2024 Michalis Zabaras. All rights reserved.</p></footer><script src="/_next/static/chunks/webpack-65b272b162965a52.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/29242e86bbe0719e.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L3\"\n"])</script><script>self.__next_f.push([1,"4:HL[\"/_next/static/css/c95096fc0885ed51.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"5:I[7732,[],\"\"]\n8:I[3107,[],\"\"]\n9:I[6865,[],\"\"]\na:I[2088,[\"139\",\"static/chunks/139-49b50a3bf6f25794.js\",\"254\",\"static/chunks/254-700dd0f479925ac0.js\",\"313\",\"static/chunks/313-3c66015e67682b11.js\",\"517\",\"static/chunks/app/posts/layout-3c2a5579c52700c6.js\"],\"\"]\nb:I[9254,[\"221\",\"static/chunks/53dc2434-cbba9649805a64e5.js\",\"139\",\"static/chunks/139-49b50a3bf6f25794.js\",\"254\",\"static/chunks/254-700dd0f479925ac0.js\",\"931\",\"static/chunks/app/page-6102fbb40167a089.js\"],\"\"]\nd:I[8022,[],\"\"]\n7:T4b2,// file: /src/core/Routes.ts\nexport class Routes {\n  engine: Engine;\n  routes: { [key: string]: IRoute };\n\n  constructor(engine: Engine) {\n    this.engine = engine;\n    this.routes = {};\n  }\n\n  addRoute(props: Optional\u003cIRoute, \"id\"\u003e) {\n    const id = props.id || uuidv4();\n    this.routes[id] = { ...props, id };\n\n    this.plug(id);\n  }\n\n  removeRoute(id: string) {\n    this.unPlug(id);\n    delete this.routes[id];\n  }\n\n  private plug(id: string) {\n    const { sourceIO, destinationIO } = this.getIOs(id);\n    sourceIO.plug(destinationIO);\n  }\n\n  private unPlug(id: string) {\n    const { sourceIO, destinationIO } = this.getIOs(id);\n    sourceIO.unPlug(destinationIO);\n  }\n\n  private find(id: string): IRoute {\n    if (!this.routes[id]) throw Error(`Route with id ${id} not found`);\n\n    return this.routes[id];\n  }\n\n  private getIOs(id: string) {\n    const route = this.find(id);\n    const { source, destination } = route;\n\n    const sourceIO = this.engine.findIO(\n      source.moduleId,\n      source.ioName,\n      \"output\",\n    );\n    const destinationIO = this.engine.findIO(\n      destination.moduleId,\n      destination.ioName,\n      \"input\",\n    );\n\n    return { sourceIO, destinationIO };\n  }\n}\ne:[]\n"])</script><script>self.__next_f.push([1,"3:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/29242e86bbe0719e.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"3uoyBDtbehB7xixUODJ60\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/posts/web-audio-engine-part4\",\"initialTree\":[\"\",{\"children\":[\"posts\",{\"children\":[\"web-audio-engine-part4\",{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"posts\",{\"children\":[\"web-audio-engine-part4\",{\"children\":[\"__PAGE__\",{},[\"$L6\",[[\"$\",\"h1\",null,{\"children\":\"Web Audio Engine Part 4 - implementing Advanced I/O\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"In the \",[\"$\",\"a\",null,{\"href\":\"/posts/web-audio-engine-part3\",\"children\":\"previous post\"}],\", we began integrating Web Audio and implemented a basic connect functionality, allowing us to link modules together.\\nHowever, this basic functionality has limitations when it comes to building more complex audio systems. It lacks the flexibility and control needed for advanced audio processing tasks.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"To overcome these limitations, in this post, we will explore and implement a more advanced and modular I/O system.\\nThis new system will provide greater control over connections, enabling us to create more intricate and scalable audio setups.\\nAdditionally, this enhanced I/O system will offer users detailed information about the available I/Os of a module and the current connections between these I/Os.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Before we continue I'm suggesting to do a fast diagonal reading if you have already read it before, or a more detailed reading if you haven't to\\n\",[\"$\",\"a\",null,{\"href\":\"/posts/web-audio-engine-part1\",\"children\":\"part1\"}],\",\\n\",[\"$\",\"a\",null,{\"href\":\"/posts/web-audio-engine-part2\",\"children\":\"part2\"}],\",\\n\",[\"$\",\"a\",null,{\"href\":\"/posts/web-audio-engine-part3\",\"children\":\"part3\"}],\".\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"You can find the codebase up to this point on the \",[\"$\",\"a\",null,{\"href\":\"https://github.com/mikezaby/web_audio_engine/tree/advanced-io\",\"children\":\"advanced-io\"}],\" branch,\\nor you can view the additions compared with the previous post \",[\"$\",\"a\",null,{\"href\":\"https://github.com/mikezaby/web_audio_engine/compare/audio-node...advanced-io\",\"children\":\"here\"}],\".\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Data Structure\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"We will start with the data structure.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"First, let's describe the data structure of an I/O:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"{\\n  id: string,\\n  name: string,\\n  ioType: IOType,\\n  moduleId: string,\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The \",[\"$\",\"code\",null,{\"children\":\"IOType\"}],\" will keep all the available I/O types that we will implement.\\nIn this post, we will implement \",[\"$\",\"code\",null,{\"children\":\"AudioInput\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"AudioOutput\"}],\", but in the next iteration, we will add support for \",[\"$\",\"code\",null,{\"children\":\"MidiInput\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"MidiOutput\"}],\".\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/Base.ts\\nenum IOType {\\n  AudioInput = \\\"audioInput\\\",\\n  AudioOutput = \\\"audioOutput\\\",\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Next, we want to define the data structure that describes the connection between an input and an output.\\nWe name this connection a \",[\"$\",\"code\",null,{\"children\":\"Route\"}],\".\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"{\\n  id: string,\\n  source: { ioName: string, moduleId: string },\\n  destination: { ioName: string, moduleId: string }\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"We decided to use \",[\"$\",\"code\",null,{\"children\":\"ioName\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"moduleId\"}],\" as the information for the source and destination instead of just the I/O id.\\nThis decision allows us to quickly determine which module an I/O belongs to, and using ioName instead of an id makes it more human-friendly.\\nWe also enforce unique name validation to avoid problems with duplicate names.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"So this information is enough to know which I/Os are available and the connections between them.\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"File Structure\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"In this post, we will implement the \",[\"$\",\"code\",null,{\"children\":\"Base\"}],\" class for our I/O, the \",[\"$\",\"code\",null,{\"children\":\"AudioIO\"}],\", which will handle the connections between \",[\"$\",\"code\",null,{\"children\":\"AudioNode\"}],\" outputs and \",[\"$\",\"code\",null,{\"children\":\"AudioNode\"}],\" inputs or \",[\"$\",\"code\",null,{\"children\":\"AudioParams\"}],\".\\nAdditionally, we will implement a collection that will help us define easily the desired inputs and outputs for each module.\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"- src\\n  - core\\n    - IO\\n      - index.ts\\n      - Base.ts\\n      - AudioIO.ts\\n      - Collection.ts\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"The Base IO Class\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"We want to define the interface for the I/O based on the data that we showed before.\\nTo initialize an I/O, we need to know the name of the I/O and its type.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/Base.ts\\ninterface IOProps {\\n  name: string;\\n  ioType: IOType;\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"For serialization, we need to extend the previous interface with the information of I/O id and moduleId.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/Base.ts\\ninterface IIOSerialize extends IOProps {\\n  id: string;\\n  moduleId: string;\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Constructor\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"To define an I/O, we also need to know which module it belongs to, for this reason, we pass this argument in the constructor.\\nWe use a deterministic id generation based on module id and I/O name.\\nWe do this because we want unique ids, but we also want the ability to reproduce the same id when we have the same module id and I/O name.\\nLastly, we want to keep track of the connections of this I/O.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/Base.ts\\nabstract class Base implements IOProps {\\n  id: string;\\n  ioType: IOType;\\n  name: string;\\n  module: AnyModule;\\n  connections: Base[];\\n\\n  constructor(module: AnyModule, props: IOProps) {\\n    this.module = module;\\n    this.name = props.name;\\n    this.ioType = props.ioType;\\n    this.id = deterministicId(this.module.id, this.name);\\n    this.connections = [];\\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Plug/UnPlug\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"We want a standardized procedure for any I/O type that can be plugged or unplugged, and these functions can be overridden with extra logic based on specific I/O type needs.\\nThe only thing that we want from basic plug/unplug functionality is to update the connections.\\nAlso, because we want both input and output informed about the connection, we have a flag to know if we need to call the plug/unPlug function in the opposite way.\\nWe also have an unPlugAll functionality to easily unplug all connections.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/Base.ts\\nplug(io: Base, plugOther: boolean = true) {\\n  this.connections.push(io);\\n  if (plugOther) io.plug(this, false);\\n}\\n\\nunPlug(io: Base, plugOther: boolean = true) {\\n  this.connections = this.connections.filter(\\n    (currentIO) =\u003e currentIO.id !== io.id,\\n  );\\n  if (plugOther) io.unPlug(this, false);\\n}\\n\\nunPlugAll() {\\n  this.connections.forEach((otherIO) =\u003e this.unPlug(otherIO));\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Serialize\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"We want to serialize the data of the I/O based on what we discussed in the \",[\"$\",\"strong\",null,{\"children\":\"Data Structure\"}],\" section.\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/Base.ts\\nserialize(): IIOSerialize {\\n  return {\\n    id: this.id,\\n    name: this.name,\\n    ioType: this.ioType,\\n    moduleId: this.module.id,\\n  };\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Handling Connection As Geneneric\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"In some cases may we don't want to change to plug/unPlug anything else than what is the \",[\"$\",\"code\",null,{\"children\":\"Connection\"}],\",\\nso we make an aditional class that will extends \",[\"$\",\"code\",null,{\"children\":\"Base\"}],\" with the ability to set a generic about the \",[\"$\",\"code\",null,{\"children\":\"Connection\"}],\".\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/Base.ts\\nabstract class IO\u003cConnection extends Base\u003e extends Base {\\n  declare connections: Connection[];\\n\\n  constructor(module: AnyModule, props: IOProps) {\\n    super(module, props);\\n  }\\n\\n  plug(io: Connection, plugOther?: boolean): void {\\n    super.plug(io, plugOther);\\n  }\\n\\n  unPlug(io: Connection, plugOther?: boolean): void {\\n    super.unPlug(io, plugOther);\\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"AudioIO\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"We want to adjust \",[\"$\",\"code\",null,{\"children\":\"IOProps\"}],\" to set specific types for \",[\"$\",\"code\",null,{\"children\":\"AudioInputProps\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"AudioOutputProps\"}],\", and extend them with an extra field \",[\"$\",\"code\",null,{\"children\":\"getAudioNode\"}],\", which is a callback that returns an \",[\"$\",\"code\",null,{\"children\":\"AudioNode\"}],\" for output, as only the AudioNode has the ability to call connect.\\nFor inputs, the callback returns an \",[\"$\",\"code\",null,{\"children\":\"AudioNode\"}],\", \",[\"$\",\"code\",null,{\"children\":\"AudioParam\"}],\", or \",[\"$\",\"code\",null,{\"children\":\"AudioDestinationNode\"}],\" because all of this are able to be connected to an AudioNode.\\nWe use a callback instead of a simple property because the AudioNode may change.\\nFor example, with an Oscillator, we have to create a new OscillatorNode every time we stop it.\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/AudioIO.ts\\nexport interface AudioInputProps extends IOProps {\\n  ioType: IOType.AudioInput;\\n  getAudioNode: () =\u003e AudioNode | AudioParam | AudioDestinationNode;\\n}\\n\\nexport interface AudioOutputProps extends IOProps {\\n  ioType: IOType.AudioOutput;\\n  getAudioNode: () =\u003e AudioNode;\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The implementation of \",[\"$\",\"code\",null,{\"children\":\"AudioInput\"}],\" is straightforward:\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/AudioIO.ts\\nclass AudioInput extends IO\u003cAudioOutput\u003e implements AudioInputProps {\\n  declare ioType: IOType.AudioInput;\\n  getAudioNode: AudioInputProps[\\\"getAudioNode\\\"];\\n\\n  constructor(module: AnyModule, props: AudioInputProps) {\\n    super(module, props);\\n    this.getAudioNode = props.getAudioNode;\\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"In the \",[\"$\",\"code\",null,{\"children\":\"AudioOutput\"}],\", we will add the extra code that should be executed when we plug or unplug.\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/AudioIO.ts\\nexport class AudioOutput extends IO\u003cAudioInput\u003e implements AudioOutputProps {\\n  declare ioType: IOType.AudioOutput;\\n  getAudioNode!: AudioOutputProps[\\\"getAudioNode\\\"];\\n\\n  constructor(module: AnyModule, props: AudioOutputProps) {\\n    super(module, props);\\n    this.getAudioNode = props.getAudioNode;\\n  }\\n\\n  plug(io: AudioInput, plugOther: boolean = true) {\\n    super.plug(io, plugOther);\\n    const input = io.getAudioNode();\\n\\n    if (input instanceof AudioParam) {\\n      this.getAudioNode().connect(input);\\n    } else {\\n      this.getAudioNode().connect(input);\\n    }\\n  }\\n\\n  unPlug(io: AudioInput, plugOther: boolean = true) {\\n    super.unPlug(io, plugOther);\\n    const input = io.getAudioNode();\\n\\n    try {\\n      if (input instanceof AudioParam) {\\n        this.getAudioNode().disconnect(input);\\n      } else {\\n        this.getAudioNode().disconnect(input);\\n      }\\n    } catch (e) {\\n      console.error(e);\\n    }\\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Unfortunately, we have an awkward handling to connect an \",[\"$\",\"code\",null,{\"children\":\"AudioNode\"}],\" to an \",[\"$\",\"code\",null,{\"children\":\"AudioParam\"}],\".\\nWhile the connect method allows connecting an \",[\"$\",\"code\",null,{\"children\":\"AudioNode\"}],\" to an \",[\"$\",\"code\",null,{\"children\":\"AudioParam\"}],\", due to a TypeScript \",[\"$\",\"a\",null,{\"href\":\"https://github.com/microsoft/TypeScript/issues/14107\",\"children\":\"issue\"}],\", we have to handle it like this.\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Collection\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The last tool for I/O will be the \",[\"$\",\"code\",null,{\"children\":\"Collection\"}],\".\\nWe want the integration to be as easy as possible and ensure proper separation of concerns.\\nTherefore, we need a class that will serve as a collection of Inputs or Outputs and handle tasks such as adding a new I/O, finding an existing one, and serializing the collection.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"As mentioned, we want two collection types: Input and Output.\\nCurrently, we have only one type of Node for each collection type.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/Collection.ts\\nenum CollectionType {\\n  Input = \\\"Input\\\",\\n  Output = \\\"Output\\\",\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Constructor\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"We need a class that will take a generic type representing the \",[\"$\",\"code\",null,{\"children\":\"CollectionType\"}],\".\\nWe will use this generic type later to match properties appropriately based on the collection type.\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/Collection.ts\\nabstract class IOCollection\u003cT extends CollectionType\u003e {\\n  module: AnyModule;\\n  collection: Base[] = [];\\n  collectionType: T;\\n\\n  constructor(collectionType: T, module: AnyModule) {\\n    this.collectionType = collectionType;\\n    this.module = module;\\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Add I/O\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"We want to create an interface that will map the appropriate properties based on the collection type.\\nThis allows us to avoid incorrect usage at an early stage through type checking.\\nFinally, we need to validate the uniqueness of the I/O name in this collection.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/Collection.ts\\ninterface IMappedIOProps {\\n  [CollectionType.Input]: AudioInputProps;\\n  [CollectionType.Output]: AudioOutputProps;\\n}\\n\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/Collection.ts\\nadd(props: IMappedIOProps[T]) {\\n  let io: Base;\\n  this.validateUniqName(props.name);\\n\\n  switch (props.ioType) {\\n    case IOType.AudioInput:\\n      io = new AudioInput(this.module, props);\\n      break;\\n    case IOType.AudioOutput:\\n      io = new AudioOutput(this.module, props);\\n      break;\\n    default:\\n      assertNever(props);\\n  }\\n\\n  this.collection.push(io);\\n\\n  return io;\\n}\\n\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/Collection.ts\\nprivate validateUniqName(name: string) {\\n  if (this.collection.some((io) =\u003e io.name === name)) {\\n    throw Error(`An I/O with name ${name} already exists`);\\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Finders And Serializer\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"These functions are straightforward:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/Collection.ts\\nfind(id: string) {\\n  const io = this.collection.find((io) =\u003e io.id === id);\\n  if (!io) throw Error(`The I/O with id ${id} does not exists`);\\n\\n  return io;\\n}\\n\\nfindByName(name: string) {\\n  const io = this.collection.find((io) =\u003e io.name === name);\\n  if (!io) throw Error(`The I/O with name ${name} does not exists`);\\n\\n  return io;\\n}\\n\\nserialize() {\\n  return this.collection.map((io) =\u003e io.serialize());\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Input/OutputCollection\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"To facilitate easier usage in the module, we expose \",[\"$\",\"code\",null,{\"children\":\"InputCollection\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"OutputCollection\"}],\":\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/Collection.ts\\nexport class InputCollection extends IOCollection\u003cCollectionType.Input\u003e {\\n  constructor(module: AnyModule) {\\n    super(CollectionType.Input, module);\\n  }\\n}\\n\\nexport class OutputCollection extends IOCollection\u003cCollectionType.Output\u003e {\\n  constructor(module: AnyModule) {\\n    super(CollectionType.Output, module);\\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Base Module Integration\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In the Base module constructor, we initialize Input/OutputCollection:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/Module.ts\\n// function: constructor\\nthis.inputs = new InputCollection(this);\\nthis.outputs = new OutputCollection(this);\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Then we want to provide an easy way to define audio inputs/outputs:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/Module.ts\\nprotected registerAudioInput(props: Omit\u003cAudioInputProps, \\\"ioType\\\"\u003e) {\\n  this.inputs.add({ ...props, ioType: IOType.AudioInput });\\n}\\n\\nprotected registerAudioOutput(props: Omit\u003cAudioOutputProps, \\\"ioType\\\"\u003e) {\\n  this.outputs.add({ ...props, ioType: IOType.AudioOutput });\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"We will see the usage of this as we also want to give the ability to define some common I/Os.\\nThe most common case is to define the module's main input and output \",[\"$\",\"code\",null,{\"children\":\"AudioNode\"}],\".\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/Module.ts\\nprotected registerDefaultIOs(value: \\\"both\\\" | \\\"in\\\" | \\\"out\\\" = \\\"both\\\") {\\n  if (value === \\\"in\\\" || value === \\\"both\\\") {\\n    this.registerAudioInput({\\n      name: \\\"in\\\",\\n      getAudioNode: () =\u003e this.audioNode,\\n    });\\n  }\\n\\n  if (value === \\\"out\\\" || value === \\\"both\\\") {\\n    this.registerAudioOutput({\\n      name: \\\"out\\\",\\n      getAudioNode: () =\u003e this.audioNode,\\n    });\\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"We also want to add information about the available I/Os to the serialize function:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/Module.ts\\ninterface IModuleSerialize\u003cT extends ModuleType\u003e extends IModule\u003cT\u003e {\\n  inputs: IIOSerialize[];\\n  outputs: IIOSerialize[];\\n}\\n\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/Module.ts\\nserialize(): IModuleSerialize\u003cT\u003e {\\n  return {\\n    id: this.id,\\n    name: this.name,\\n    moduleType: this.moduleType,\\n    props: this.props,\\n    inputs: this.inputs.serialize(),\\n    outputs: this.outputs.serialize(),\\n  };\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Define I/Os To Available Modules\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Now we are ready to define the I/Os for the actual modules.\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Volume\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The volume module has both an input and an output, as we connect a signal to its input and take the adjusted signal from its output.\\nSo, we will define both input and output.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/modules/Volume.ts\\n// function: constructor\\nthis.registerDefaultIOs();\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Master\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The master module has only an input, which allows any module to reach our audio interface.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/modules/Master.ts\\n// function: constructor\\nthis.registerDefaultIOs(\\\"in\\\");\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Oscillator\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Conversely, the oscillator has only an output, as the oscillator generates the signal.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/modules/Oscillator.ts\\n// function: constructor\\n\\nthis.initializeGainDetune();\\nthis.registerDefaultIOs(\\\"out\\\");\\nthis.registerInputs();\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"However, we will define an input for the \",[\"$\",\"code\",null,{\"children\":\"detune\"}],\" \",[\"$\",\"code\",null,{\"children\":\"AudioParam\"}],\".\\nWith this setup, we allow the ability to automatically mutate the frequency.\\nFor example, we can connect another oscillator to detune.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The \",[\"$\",\"code\",null,{\"children\":\"OscillatorNode.detune\"}],\" parameter changes the original frequency by one semitone for every 100 cents.\\nWe want to apply values from -1 to 1 to change the original frequency by one semitone.\\nTherefore, we create an extra \",[\"$\",\"code\",null,{\"children\":\"GainNode\"}],\" with a value of 100, connect it to \",[\"$\",\"code\",null,{\"children\":\"audioNode.detune\"}],\", and then expose the \",[\"$\",\"code\",null,{\"children\":\"detuneGain\"}],\" instead of \",[\"$\",\"code\",null,{\"children\":\"audioNode.detune\"}],\".\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/modules/Oscillator.ts\\nprivate initializeGainDetune() {\\n  this.detuneGain = new GainNode(this.context, { gain: 100 });\\n  this.detuneGain.connect(this.audioNode.detune);\\n}\\n\\nprivate registerInputs() {\\n  this.registerAudioInput({\\n    name: \\\"detune\\\",\\n    getAudioNode: () =\u003e this.detuneGain,\\n  });\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Implement rePlug functionality\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Unfortunately, we haven't finished yet with the oscillator.\\nAs we discussed in the previous post, every time we stop the oscillator, we have to generate a new \",[\"$\",\"code\",null,{\"children\":\"OscillatorNode\"}],\" to start it again.\\nThis means we need to build a replug mechanism that will allow us to replug all the connected I/Os.\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Oscillator\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"I'll start by explaining how I'd like to use the replug mechanism.\\nWe want a function that will accept a callback, so internally we will unplug all I/Os, run the desired code, and then replug the I/Os.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/modules/Oscillator.ts\\nstop(time: number) {\\n  this.audioNode.stop(time);\\n  this.rePlugAll(() =\u003e {\\n    this.audioNode = new OscillatorNode(this.context, {\\n      type: this.props[\\\"wave\\\"],\\n      frequency: this.props[\\\"frequency\\\"],\\n    });\\n  });\\n\\n  this.isStated = false;\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Base Module\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The implementation of the rePlugAll mechanism in the base module is simple, as we just delegate the functionality to the input/output collection.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/Module.ts\\nprotected rePlugAll(callback?: () =\u003e void) {\\n  this.inputs.rePlugAll(callback);\\n  this.outputs.rePlugAll(callback);\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Collection\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The collection again delegates the functionality to each I/O.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/Collection.ts\\nrePlugAll(callback?: () =\u003e void) {\\n  this.collection.forEach((io) =\u003e io.rePlugAll(callback));\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Base I/O\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Finally, we will implement the actual replug functionality in the Base I/O.\\nWe keep the connected I/Os in a variable, so we can unplug them, call the callback, and then replug all the connections.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/IO/Base.ts\\nrePlugAll(callback?: () =\u003e void) {\\n  const connections = this.connections;\\n  this.unPlugAll();\\n  if (callback) callback();\\n\\n  connections.forEach((otherIO) =\u003e this.plug(otherIO));\\n}\\n\\nunPlugAll() {\\n  this.connections.forEach((otherIO) =\u003e this.unPlug(otherIO));\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Routes\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"We have integrated our I/O system into the modules, so it's time to expose it to the engine.\\nWe will create a \",[\"$\",\"code\",null,{\"children\":\"Routes\"}],\" class responsible for keeping route information and providing the API that will be exposed to the engine, allowing us to add and remove routes.\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Implementation\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"We discussed in the beginning how a route data looks.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"{\\n  id: string,\\n  source: { ioName: string, moduleId: string },\\n  destination: { ioName: string, moduleId: string }\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This will be translated to a TypeScript interface like this:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/core/Routes.ts\\ninterface IPlug {\\n  moduleId: string;\\n  ioName: string;\\n}\\n\\ninterface IRoute {\\n  id: string;\\n  source: IPlug;\\n  destination: IPlug;\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"I'll provide the whole code at once as it is relatively simple.\\nIn the constructor of the class, we pass the engine so we can find the desired modules from it and, more specifically, the desired I/O of a module.\\nWe keep the information of the routes in an object where the key is the id of the route and the value is the \",[\"$\",\"code\",null,{\"children\":\"IRoute\"}],\".\\nThe only available public functions will be \",[\"$\",\"code\",null,{\"children\":\"addRoute\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"removeRoute\"}],\".\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"$7\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"We also have to implement the \",[\"$\",\"code\",null,{\"children\":\"findIO\"}],\" function as it doesn't exist yet.\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/Engine.ts\\nfindIO(moduleId: string, ioName: string, type: \\\"input\\\" | \\\"output\\\") {\\n  const module = this.findModule(moduleId);\\n  return module[`${type}s`].findByName(ioName);\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"Expose to Engine\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Finally, we need to integrate \",[\"$\",\"code\",null,{\"children\":\"Routes\"}],\" into the engine and expose \",[\"$\",\"code\",null,{\"children\":\"addRoute\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"removeRoute\"}],\".\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"We start by defining the routes property in the engine:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/Engine.ts\\nroutes: Routes;\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Initialize it in the constructor:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/Engine.ts\\n// function: constructor\\nthis.routes = new Routes(this);\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"And then expose the \",[\"$\",\"code\",null,{\"children\":\"addRoute\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"removeRoute\"}],\" methods:\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// file: /src/Engine.ts\\naddRoute(props: Optional\u003cIRoute, \\\"id\\\"\u003e) {\\n  this.routes.addRoute(props);\\n}\\n\\nremoteRoute(id: string) {\\n  this.routes.removeRoute(id);\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Lets Have Some Fun!\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"I'll write a very simple example of code that creates a routing from an oscillator -\u003e volume -\u003e master.\\nAdditionally, I'll create an LFO, which is actually an oscillator, that will be connected to oscillator detune.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"import { Engine, ModuleType } from \\\"blibliki\\\";\\n\\nconst context = new AudioContext();\\nconst engine = new Engine(context);\\n\\nconst osc = engine.addModule({\\n  name: \\\"osc\\\",\\n  moduleType: ModuleType.Oscillator,\\n  props: { wave: \\\"sine\\\", frequency: 440 },\\n});\\n\\nconst lfo = engine.addModule({\\n  name: \\\"osc\\\",\\n  moduleType: ModuleType.Oscillator,\\n  props: { wave: \\\"sine\\\", frequency: 2 },\\n});\\n\\nconst vol = engine.addModule({\\n  name: \\\"vol\\\",\\n  moduleType: ModuleType.Volume,\\n  props: { volume: 0.01 },\\n});\\n\\nconst master = engine.addModule({\\n  name: \\\"master\\\",\\n  moduleType: ModuleType.Master,\\n  props: {},\\n});\\n\\nengine.addRoute({\\n  source: { moduleId: osc.id, ioName: \\\"out\\\" },\\n  destination: { moduleId: vol.id, ioName: \\\"in\\\" },\\n});\\nengine.addRoute({\\n  source: { moduleId: lfo.id, ioName: \\\"out\\\" },\\n  destination: { moduleId: osc.id, ioName: \\\"detune\\\" },\\n});\\nengine.addRoute({\\n  source: { moduleId: vol.id, ioName: \\\"out\\\" },\\n  destination: { moduleId: master.id, ioName: \\\"in\\\" },\\n});\\n\\nawait engine.start();\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Now, I'm challenging you to create a crazy patch, and believe it, it's possible even though we have very limited modules for now.\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Before Close\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"If you made the effort to read this post, please leave a comment or contact me. It is really important to me to hear your feedback.\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"what's next\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"I don't know yet what Part 5 will be about, but I know for sure that sooner or later, I'll write the next part!\"}]],null]]},[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\",\"web-audio-engine-part4\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[null,[\"$\",\"$La\",null,{\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],\"params\":{}}],null]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_aaf875 flex min-h-screen flex-col\",\"children\":[[\"$\",\"header\",null,{\"className\":\"container flex items-center justify-between py-4 dark:bg-gray-800\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-xl font-semibold text-gray-900 dark:text-white\",\"children\":[\"$\",\"$Lb\",null,{\"href\":\"/\",\"children\":\"Mike Zaby\"}]}],[\"$\",\"nav\",null,{\"children\":[\"$\",\"ul\",null,{\"className\":\"flex space-x-4\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"target\":\"_blank\",\"href\":\"https://github.com/mikezaby\",\"className\":\"transition-colors hover:text-gray-600 dark:hover:text-white\",\"children\":[\"$\",\"svg\",null,{\"viewBox\":\"0 0 16 16\",\"className\":\"h-5 w-5\",\"fill\":\"currentColor\",\"aria-hidden\":\"true\",\"children\":[\"$\",\"path\",null,{\"d\":\"M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z\"}]}]}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"target\":\"_blank\",\"href\":\"https://twitter.com/mikezaby\",\"className\":\"transition-colors hover:text-blue-500\",\"children\":[\"$\",\"svg\",null,{\"viewBox\":\"0 0 24 24\",\"className\":\"h-5 w-5\",\"fill\":\"currentColor\",\"aria-hidden\":\"true\",\"children\":[\"$\",\"path\",null,{\"d\":\"M24 4.557c-.883.392-1.832.656-2.828.775 1.017-.609 1.798-1.574 2.165-2.724-.951.564-2.005.974-3.127 1.195-.897-.957-2.178-1.555-3.594-1.555-3.179 0-5.515 2.966-4.797 6.045-4.091-.205-7.719-2.165-10.148-5.144-1.29 2.213-.669 5.108 1.523 6.574-.806-.026-1.566-.247-2.229-.616-.054 2.281 1.581 4.415 3.949 4.89-.693.188-1.452.232-2.224.084.626 1.956 2.444 3.379 4.6 3.419-2.07 1.623-4.678 2.348-7.29 2.04 2.179 1.397 4.768 2.212 7.548 2.212 9.142 0 14.307-7.721 13.995-14.646.962-.695 1.797-1.562 2.457-2.549z\"}]}]}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"target\":\"_blank\",\"href\":\"https://youtube.com/@mizakiro\",\"className\":\"transition-colors hover:text-red-600\",\"children\":[\"$\",\"svg\",null,{\"viewBox\":\"0 0 24 24\",\"className\":\"h-5 w-5\",\"fill\":\"currentColor\",\"aria-hidden\":\"true\",\"children\":[\"$\",\"path\",null,{\"d\":\"M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z\"}]}]}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"target\":\"_blank\",\"href\":\"https://www.linkedin.com/in/michalis-zabaras-97b5002b\",\"className\":\"transition-colors hover:text-blue-700\",\"children\":[\"$\",\"svg\",null,{\"viewBox\":\"0 0 24 24\",\"className\":\"h-5 w-5\",\"fill\":\"currentColor\",\"aria-hidden\":\"true\",\"children\":[\"$\",\"path\",null,{\"d\":\"M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z\"}]}]}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"$Lb\",null,{\"href\":\"/about\",\"className\":\"font-bold transition-colors hover:text-gray-600 dark:hover:text-white\",\"children\":\"About\"}]}]]}]}]]}],[\"$\",\"div\",null,{\"className\":\"separator\"}],[\"$\",\"main\",null,{\"className\":\"container mt-8 flex-grow\",\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/c95096fc0885ed51.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]}],[\"$\",\"footer\",null,{\"className\":\"container py-8 text-center\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-gray-600 dark:text-gray-300\",\"children\":\"Â© 2024 Michalis Zabaras. All rights reserved.\"}]}]]}]}],null]],\"initialHead\":[false,\"$Lc\"],\"globalErrorComponent\":\"$d\",\"missingSlots\":\"$We\"}]]\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Web Audio Engine Part 4 - Implementing Advanced I/O\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"In this post, we explore how to implement an advanced I/O system for our web audio engine. We'll set up modular inputs and outputs, integrate them into the engine, and create a routing mechanism\"}],[\"$\",\"meta\",\"4\",{\"name\":\"next-size-adjust\"}]]\n6:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>